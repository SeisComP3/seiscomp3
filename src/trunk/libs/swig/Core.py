# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Core')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Core')
    _Core = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Core', [dirname(__file__)])
        except ImportError:
            import _Core
            return _Core
        try:
            _mod = imp.load_module('_Core', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Core = swig_import_helper()
    del swig_import_helper
else:
    import _Core
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class RTTI(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RTTI, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RTTI, name)
    __repr__ = _swig_repr

    def __init__(self, classname, parent=None):
        this = _Core.new_RTTI(classname, parent)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, other):
        return _Core.RTTI___eq__(self, other)

    def __ne__(self, other):
        return _Core.RTTI___ne__(self, other)

    def parent(self):
        return _Core.RTTI_parent(self)

    def className(self):
        return _Core.RTTI_className(self)

    def before(self, other):
        return _Core.RTTI_before(self, other)

    def isTypeOf(self, other):
        return _Core.RTTI_isTypeOf(self, other)
    __swig_destroy__ = _Core.delete_RTTI
    __del__ = lambda self: None
RTTI_swigregister = _Core.RTTI_swigregister
RTTI_swigregister(RTTI)

class PropertyNotFoundException(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PropertyNotFoundException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PropertyNotFoundException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_PropertyNotFoundException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_PropertyNotFoundException
    __del__ = lambda self: None
PropertyNotFoundException_swigregister = _Core.PropertyNotFoundException_swigregister
PropertyNotFoundException_swigregister(PropertyNotFoundException)

class MetaEnum(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MetaEnum, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MetaEnum, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Core.delete_MetaEnum
    __del__ = lambda self: None

    def keyCount(self):
        return _Core.MetaEnum_keyCount(self)

    def key(self, index):
        return _Core.MetaEnum_key(self, index)

    def valueToKey(self, value):
        return _Core.MetaEnum_valueToKey(self, value)

    def keyToValue(self, key):
        return _Core.MetaEnum_keyToValue(self, key)
MetaEnum_swigregister = _Core.MetaEnum_swigregister
MetaEnum_swigregister(MetaEnum)

class MetaProperty(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MetaProperty, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MetaProperty, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_MetaProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_MetaProperty
    __del__ = lambda self: None

    def setInfo(self, name, type, isArray, isClass, isIndex, isReference, isOptional, isEnum, enumeration=None):
        return _Core.MetaProperty_setInfo(self, name, type, isArray, isClass, isIndex, isReference, isOptional, isEnum, enumeration)

    def name(self):
        return _Core.MetaProperty_name(self)

    def type(self):
        return _Core.MetaProperty_type(self)

    def enumerator(self):
        return _Core.MetaProperty_enumerator(self)

    def isArray(self):
        return _Core.MetaProperty_isArray(self)

    def isClass(self):
        return _Core.MetaProperty_isClass(self)

    def isIndex(self):
        return _Core.MetaProperty_isIndex(self)

    def isReference(self):
        return _Core.MetaProperty_isReference(self)

    def isEnum(self):
        return _Core.MetaProperty_isEnum(self)

    def isOptional(self):
        return _Core.MetaProperty_isOptional(self)

    def createClass(self):
        return _Core.MetaProperty_createClass(self)

    def arrayElementCount(self, object):
        return _Core.MetaProperty_arrayElementCount(self, object)

    def arrayObject(self, object, i):
        return _Core.MetaProperty_arrayObject(self, object, i)

    def arrayAddObject(self, object, child):
        return _Core.MetaProperty_arrayAddObject(self, object, child)

    def arrayRemoveObject(self, *args):
        return _Core.MetaProperty_arrayRemoveObject(self, *args)

    def write(self, object, value):
        return _Core.MetaProperty_write(self, object, value)

    def writeString(self, object, value):
        return _Core.MetaProperty_writeString(self, object, value)

    def read(self, object):
        return _Core.MetaProperty_read(self, object)

    def readString(self, object):
        return _Core.MetaProperty_readString(self, object)
MetaProperty_swigregister = _Core.MetaProperty_swigregister
MetaProperty_swigregister(MetaProperty)

class MetaObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MetaObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MetaObject, name)
    __repr__ = _swig_repr

    def __init__(self, rtti, base=None):
        this = _Core.new_MetaObject(rtti, base)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_MetaObject
    __del__ = lambda self: None

    def rtti(self):
        return _Core.MetaObject_rtti(self)

    def base(self):
        return _Core.MetaObject_base(self)

    def propertyCount(self):
        return _Core.MetaObject_propertyCount(self)

    def property(self, *args):
        return _Core.MetaObject_property(self, *args)
MetaObject_swigregister = _Core.MetaObject_swigregister
MetaObject_swigregister(MetaObject)

class TimeSpan(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSpan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSpan, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_TimeSpan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, arg2):
        return _Core.TimeSpan___eq__(self, arg2)

    def __ne__(self, arg2):
        return _Core.TimeSpan___ne__(self, arg2)

    def __lt__(self, arg2):
        return _Core.TimeSpan___lt__(self, arg2)

    def __le__(self, arg2):
        return _Core.TimeSpan___le__(self, arg2)

    def __gt__(self, arg2):
        return _Core.TimeSpan___gt__(self, arg2)

    def __ge__(self, arg2):
        return _Core.TimeSpan___ge__(self, arg2)

    def __add__(self, arg2):
        return _Core.TimeSpan___add__(self, arg2)

    def __sub__(self, arg2):
        return _Core.TimeSpan___sub__(self, arg2)

    def __iadd__(self, arg2):
        return _Core.TimeSpan___iadd__(self, arg2)

    def __isub__(self, arg2):
        return _Core.TimeSpan___isub__(self, arg2)

    def abs(self):
        return _Core.TimeSpan_abs(self)

    def seconds(self):
        return _Core.TimeSpan_seconds(self)

    def microseconds(self):
        return _Core.TimeSpan_microseconds(self)

    def length(self):
        return _Core.TimeSpan_length(self)

    def set(self, seconds):
        return _Core.TimeSpan_set(self, seconds)

    def setUSecs(self, arg2):
        return _Core.TimeSpan_setUSecs(self, arg2)

    def elapsedTime(self, days, hours=None, minutes=None, seconds=None):
        return _Core.TimeSpan_elapsedTime(self, days, hours, minutes, seconds)

    def toDouble(self):
        return _Core.TimeSpan_toDouble(self)

    def __float__(self):
            return self.length()

    __swig_destroy__ = _Core.delete_TimeSpan
    __del__ = lambda self: None
TimeSpan_swigregister = _Core.TimeSpan_swigregister
TimeSpan_swigregister(TimeSpan)
cvar = _Core.cvar
TimeSpan.MinTime = _Core.cvar.TimeSpan_MinTime
TimeSpan.MaxTime = _Core.cvar.TimeSpan_MaxTime

class Time(TimeSpan):
    __swig_setmethods__ = {}
    for _s in [TimeSpan]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Time, name, value)
    __swig_getmethods__ = {}
    for _s in [TimeSpan]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Time, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_Time(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __nonzero__(self):
        return _Core.Time___nonzero__(self)
    __bool__ = __nonzero__



    def __add__(self, arg2):
        return _Core.Time___add__(self, arg2)

    def __sub__(self, *args):
        return _Core.Time___sub__(self, *args)

    def __iadd__(self, arg2):
        return _Core.Time___iadd__(self, arg2)

    def __isub__(self, arg2):
        return _Core.Time___isub__(self, arg2)

    def set(self, year, month, day, hour, min, sec, usec):
        return _Core.Time_set(self, year, month, day, hour, min, sec, usec)

    def get(self):
        return _Core.Time_get(self)

    def get2(self):
        return _Core.Time_get2(self)
    if _newclass:
        LocalTime = staticmethod(_Core.Time_LocalTime)
    else:
        LocalTime = _Core.Time_LocalTime
    if _newclass:
        LocalTimeZone = staticmethod(_Core.Time_LocalTimeZone)
    else:
        LocalTimeZone = _Core.Time_LocalTimeZone
    if _newclass:
        GMT = staticmethod(_Core.Time_GMT)
    else:
        GMT = _Core.Time_GMT
    if _newclass:
        FromYearDay = staticmethod(_Core.Time_FromYearDay)
    else:
        FromYearDay = _Core.Time_FromYearDay

    def localTimeZoneOffset(self):
        return _Core.Time_localTimeZoneOffset(self)

    def localtime(self):
        return _Core.Time_localtime(self)

    def gmt(self):
        return _Core.Time_gmt(self)

    def toLocalTime(self):
        return _Core.Time_toLocalTime(self)

    def toGMT(self):
        return _Core.Time_toGMT(self)

    def valid(self):
        return _Core.Time_valid(self)

    def toString(self, fmt):
        return _Core.Time_toString(self, fmt)

    def iso(self):
        return _Core.Time_iso(self)

    def fromString(self, str, fmt):
        return _Core.Time_fromString(self, str, fmt)
    if _newclass:
        FromString = staticmethod(_Core.Time_FromString)
    else:
        FromString = _Core.Time_FromString

    def __str__(self):
            return self.toString("%Y-%m-%d %H:%M:%S.%f000000")[:23]

    __swig_destroy__ = _Core.delete_Time
    __del__ = lambda self: None
Time_swigregister = _Core.Time_swigregister
Time_swigregister(Time)
Time.Null = _Core.cvar.Time_Null

def Time_LocalTime():
    return _Core.Time_LocalTime()
Time_LocalTime = _Core.Time_LocalTime

def Time_LocalTimeZone():
    return _Core.Time_LocalTimeZone()
Time_LocalTimeZone = _Core.Time_LocalTimeZone

def Time_GMT():
    return _Core.Time_GMT()
Time_GMT = _Core.Time_GMT

def Time_FromYearDay(year, year_day):
    return _Core.Time_FromYearDay(year, year_day)
Time_FromYearDay = _Core.Time_FromYearDay

def Time_FromString(str, fmt):
    return _Core.Time_FromString(str, fmt)
Time_FromString = _Core.Time_FromString

class ValueError(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ValueError, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Core.new_ValueError()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_ValueError
    __del__ = lambda self: None

    def what(self):
        return _Core.ValueError_what(self)
ValueError_swigregister = _Core.ValueError_swigregister
ValueError_swigregister(ValueError)
Unset = cvar.Unset

class Enumeration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Enumeration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Enumeration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Core.delete_Enumeration
    __del__ = lambda self: None

    def toString(self):
        return _Core.Enumeration_toString(self)

    def fromString(self, str):
        return _Core.Enumeration_fromString(self, str)

    def toInt(self):
        return _Core.Enumeration_toInt(self)

    def fromInt(self, value):
        return _Core.Enumeration_fromInt(self, value)
Enumeration_swigregister = _Core.Enumeration_swigregister
Enumeration_swigregister(Enumeration)

class GeneralException(Exception):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GeneralException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GeneralException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_GeneralException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_GeneralException
    __del__ = lambda self: None

    def what(self):
        return _Core.GeneralException_what(self)

    def __str__(self):
            return self.what()

GeneralException_swigregister = _Core.GeneralException_swigregister
GeneralException_swigregister(GeneralException)

class MemoryException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MemoryException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MemoryException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_MemoryException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_MemoryException
    __del__ = lambda self: None
MemoryException_swigregister = _Core.MemoryException_swigregister
MemoryException_swigregister(MemoryException)

class StreamException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_StreamException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_StreamException
    __del__ = lambda self: None
StreamException_swigregister = _Core.StreamException_swigregister
StreamException_swigregister(StreamException)

class EndOfStreamException(StreamException):
    __swig_setmethods__ = {}
    for _s in [StreamException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndOfStreamException, name, value)
    __swig_getmethods__ = {}
    for _s in [StreamException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EndOfStreamException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_EndOfStreamException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_EndOfStreamException
    __del__ = lambda self: None
EndOfStreamException_swigregister = _Core.EndOfStreamException_swigregister
EndOfStreamException_swigregister(EndOfStreamException)

class TypeConversionException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeConversionException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeConversionException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_TypeConversionException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_TypeConversionException
    __del__ = lambda self: None
TypeConversionException_swigregister = _Core.TypeConversionException_swigregister
TypeConversionException_swigregister(TypeConversionException)

class OverflowException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OverflowException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OverflowException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_OverflowException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_OverflowException
    __del__ = lambda self: None
OverflowException_swigregister = _Core.OverflowException_swigregister
OverflowException_swigregister(OverflowException)

class UnderflowException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnderflowException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnderflowException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_UnderflowException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_UnderflowException
    __del__ = lambda self: None
UnderflowException_swigregister = _Core.UnderflowException_swigregister
UnderflowException_swigregister(UnderflowException)

class ValueException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValueException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ValueException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_ValueException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_ValueException
    __del__ = lambda self: None
ValueException_swigregister = _Core.ValueException_swigregister
ValueException_swigregister(ValueException)

class TypeException(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TypeException, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TypeException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_TypeException(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_TypeException
    __del__ = lambda self: None
TypeException_swigregister = _Core.TypeException_swigregister
TypeException_swigregister(TypeException)

class ClassNotFound(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassNotFound, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassNotFound, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_ClassNotFound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_ClassNotFound
    __del__ = lambda self: None
ClassNotFound_swigregister = _Core.ClassNotFound_swigregister
ClassNotFound_swigregister(ClassNotFound)

class DuplicateClassname(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DuplicateClassname, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DuplicateClassname, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_DuplicateClassname(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_DuplicateClassname
    __del__ = lambda self: None
DuplicateClassname_swigregister = _Core.DuplicateClassname_swigregister
DuplicateClassname_swigregister(DuplicateClassname)


def intrusive_ptr_add_ref(*args):
    return _Core.intrusive_ptr_add_ref(*args)
intrusive_ptr_add_ref = _Core.intrusive_ptr_add_ref

def intrusive_ptr_release(*args):
    return _Core.intrusive_ptr_release(*args)
intrusive_ptr_release = _Core.intrusive_ptr_release
class BaseObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.BaseObject_ClassName)
    else:
        ClassName = _Core.BaseObject_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.BaseObject_TypeInfo)
    else:
        TypeInfo = _Core.BaseObject_TypeInfo

    def className(self):
        return _Core.BaseObject_className(self)

    def typeInfo(self):
        return _Core.BaseObject_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.BaseObject_Cast)
    else:
        Cast = _Core.BaseObject_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.BaseObject_ConstCast)
    else:
        ConstCast = _Core.BaseObject_ConstCast

    def serialize(self, arg2):
        return _Core.BaseObject_serialize(self, arg2)
    if _newclass:
        Meta = staticmethod(_Core.BaseObject_Meta)
    else:
        Meta = _Core.BaseObject_Meta

    def meta(self):
        return _Core.BaseObject_meta(self)
    __swig_destroy__ = _Core.delete_BaseObject
    __del__ = lambda self: None

    def clone(self):
        return _Core.BaseObject_clone(self)

    def incrementReferenceCount(self):
        return _Core.BaseObject_incrementReferenceCount(self)

    def decrementReferenceCount(self):
        return _Core.BaseObject_decrementReferenceCount(self)

    def referenceCount(self):
        return _Core.BaseObject_referenceCount(self)
    if _newclass:
        ObjectCount = staticmethod(_Core.BaseObject_ObjectCount)
    else:
        ObjectCount = _Core.BaseObject_ObjectCount
BaseObject_swigregister = _Core.BaseObject_swigregister
BaseObject_swigregister(BaseObject)

def BaseObject_ClassName():
    return _Core.BaseObject_ClassName()
BaseObject_ClassName = _Core.BaseObject_ClassName

def BaseObject_TypeInfo():
    return _Core.BaseObject_TypeInfo()
BaseObject_TypeInfo = _Core.BaseObject_TypeInfo

def BaseObject_Cast(*args):
    return _Core.BaseObject_Cast(*args)
BaseObject_Cast = _Core.BaseObject_Cast

def BaseObject_ConstCast(*args):
    return _Core.BaseObject_ConstCast(*args)
BaseObject_ConstCast = _Core.BaseObject_ConstCast

def BaseObject_Meta():
    return _Core.BaseObject_Meta()
BaseObject_Meta = _Core.BaseObject_Meta

def BaseObject_ObjectCount():
    return _Core.BaseObject_ObjectCount()
BaseObject_ObjectCount = _Core.BaseObject_ObjectCount

class Alarmable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Alarmable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Alarmable, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Core.new_Alarmable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_Alarmable
    __del__ = lambda self: None
Alarmable_swigregister = _Core.Alarmable_swigregister
Alarmable_swigregister(Alarmable)

class Interruptible(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interruptible, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interruptible, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Core.new_Interruptible()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_Interruptible
    __del__ = lambda self: None
    if _newclass:
        Interrupt = staticmethod(_Core.Interruptible_Interrupt)
    else:
        Interrupt = _Core.Interruptible_Interrupt
Interruptible_swigregister = _Core.Interruptible_swigregister
Interruptible_swigregister(Interruptible)

def Interruptible_Interrupt(sig):
    return _Core.Interruptible_Interrupt(sig)
Interruptible_Interrupt = _Core.Interruptible_Interrupt

class OperationInterrupted(GeneralException):
    __swig_setmethods__ = {}
    for _s in [GeneralException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OperationInterrupted, name, value)
    __swig_getmethods__ = {}
    for _s in [GeneralException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OperationInterrupted, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_OperationInterrupted(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_OperationInterrupted
    __del__ = lambda self: None
OperationInterrupted_swigregister = _Core.OperationInterrupted_swigregister
OperationInterrupted_swigregister(OperationInterrupted)

class InterruptibleObject(BaseObject, Interruptible, Alarmable):
    __swig_setmethods__ = {}
    for _s in [BaseObject, Interruptible, Alarmable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterruptibleObject, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseObject, Interruptible, Alarmable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InterruptibleObject, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.InterruptibleObject_ClassName)
    else:
        ClassName = _Core.InterruptibleObject_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.InterruptibleObject_TypeInfo)
    else:
        TypeInfo = _Core.InterruptibleObject_TypeInfo

    def className(self):
        return _Core.InterruptibleObject_className(self)

    def typeInfo(self):
        return _Core.InterruptibleObject_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.InterruptibleObject_Cast)
    else:
        Cast = _Core.InterruptibleObject_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.InterruptibleObject_ConstCast)
    else:
        ConstCast = _Core.InterruptibleObject_ConstCast

    def __init__(self):
        this = _Core.new_InterruptibleObject()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_InterruptibleObject
    __del__ = lambda self: None
InterruptibleObject_swigregister = _Core.InterruptibleObject_swigregister
InterruptibleObject_swigregister(InterruptibleObject)

def InterruptibleObject_ClassName():
    return _Core.InterruptibleObject_ClassName()
InterruptibleObject_ClassName = _Core.InterruptibleObject_ClassName

def InterruptibleObject_TypeInfo():
    return _Core.InterruptibleObject_TypeInfo()
InterruptibleObject_TypeInfo = _Core.InterruptibleObject_TypeInfo

def InterruptibleObject_Cast(*args):
    return _Core.InterruptibleObject_Cast(*args)
InterruptibleObject_Cast = _Core.InterruptibleObject_Cast

def InterruptibleObject_ConstCast(*args):
    return _Core.InterruptibleObject_ConstCast(*args)
InterruptibleObject_ConstCast = _Core.InterruptibleObject_ConstCast

SC_API_VERSION = _Core.SC_API_VERSION
class Version(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_Version(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def majorTag(self):
        return _Core.Version_majorTag(self)

    def minorTag(self):
        return _Core.Version_minorTag(self)

    def toString(self):
        return _Core.Version_toString(self)

    def fromString(self, str):
        return _Core.Version_fromString(self, str)
    if _newclass:
        pack = staticmethod(_Core.Version_pack)
    else:
        pack = _Core.Version_pack

    def __eq__(self, other):
        return _Core.Version___eq__(self, other)

    def __ne__(self, other):
        return _Core.Version___ne__(self, other)

    def __lt__(self, other):
        return _Core.Version___lt__(self, other)

    def __gt__(self, other):
        return _Core.Version___gt__(self, other)

    def __le__(self, other):
        return _Core.Version___le__(self, other)

    def __ge__(self, other):
        return _Core.Version___ge__(self, other)
    __swig_setmethods__["packed"] = _Core.Version_packed_set
    __swig_getmethods__["packed"] = _Core.Version_packed_get
    if _newclass:
        packed = _swig_property(_Core.Version_packed_get, _Core.Version_packed_set)
    __swig_destroy__ = _Core.delete_Version
    __del__ = lambda self: None
Version_swigregister = _Core.Version_swigregister
Version_swigregister(Version)

def Version_pack(major, minor):
    return _Core.Version_pack(major, minor)
Version_pack = _Core.Version_pack

class FrameworkVersion(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameworkVersion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameworkVersion, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Core.new_FrameworkVersion()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toString(self):
        return _Core.FrameworkVersion_toString(self)

    def systemInfo(self):
        return _Core.FrameworkVersion_systemInfo(self)
    __swig_destroy__ = _Core.delete_FrameworkVersion
    __del__ = lambda self: None
FrameworkVersion_swigregister = _Core.FrameworkVersion_swigregister
FrameworkVersion_swigregister(FrameworkVersion)

class GenericArchive(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericArchive, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericArchive, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NONE = _Core.GenericArchive_NONE
    STATIC_TYPE = _Core.GenericArchive_STATIC_TYPE
    IGNORE_CHILDS = _Core.GenericArchive_IGNORE_CHILDS
    XML_ELEMENT = _Core.GenericArchive_XML_ELEMENT
    XML_CDATA = _Core.GenericArchive_XML_CDATA
    XML_MANDATORY = _Core.GenericArchive_XML_MANDATORY
    DB_TABLE = _Core.GenericArchive_DB_TABLE
    SPLIT_TIME = _Core.GenericArchive_SPLIT_TIME
    INDEX_ATTRIBUTE = _Core.GenericArchive_INDEX_ATTRIBUTE
    __swig_destroy__ = _Core.delete_GenericArchive
    __del__ = lambda self: None
    if _newclass:
        PackVersion = staticmethod(_Core.GenericArchive_PackVersion)
    else:
        PackVersion = _Core.GenericArchive_PackVersion

    def open(self, dataSource):
        return _Core.GenericArchive_open(self, dataSource)

    def create(self, dataSource):
        return _Core.GenericArchive_create(self, dataSource)

    def close(self):
        return _Core.GenericArchive_close(self)

    def setStrictMode(self, strict):
        return _Core.GenericArchive_setStrictMode(self, strict)

    def isStrictMode(self):
        return _Core.GenericArchive_isStrictMode(self)

    def isReading(self):
        return _Core.GenericArchive_isReading(self)

    def success(self):
        return _Core.GenericArchive_success(self)

    def hint(self):
        return _Core.GenericArchive_hint(self)

    def setHint(self, arg2):
        return _Core.GenericArchive_setHint(self, arg2)

    def setValidity(self, arg2):
        return _Core.GenericArchive_setValidity(self, arg2)

    def setVersion(self, v):
        return _Core.GenericArchive_setVersion(self, v)

    def version(self):
        return _Core.GenericArchive_version(self)

    def versionMajor(self):
        return _Core.GenericArchive_versionMajor(self)

    def versionMinor(self):
        return _Core.GenericArchive_versionMinor(self)

    def propertyCount(self):
        return _Core.GenericArchive_propertyCount(self)

    def setProperty(self, name, v):
        return _Core.GenericArchive_setProperty(self, name, v)

    def property(self, name):
        return _Core.GenericArchive_property(self, name)

    def propertyInt(self, name):
        return _Core.GenericArchive_propertyInt(self, name)

    def propertyDouble(self, name):
        return _Core.GenericArchive_propertyDouble(self, name)

    def propertyString(self, name):
        return _Core.GenericArchive_propertyString(self, name)

    def clearProperties(self):
        return _Core.GenericArchive_clearProperties(self)

    def read(self, *args):
        return _Core.GenericArchive_read(self, *args)

    def write(self, *args):
        return _Core.GenericArchive_write(self, *args)

    def readObject(self):
        return _Core.GenericArchive_readObject(self)

    def writeObject(self, obj):
        return _Core.GenericArchive_writeObject(self, obj)
GenericArchive_swigregister = _Core.GenericArchive_swigregister
GenericArchive_swigregister(GenericArchive)

def GenericArchive_PackVersion(major, minor):
    return _Core.GenericArchive_PackVersion(major, minor)
GenericArchive_PackVersion = _Core.GenericArchive_PackVersion

class Status(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Status, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Status, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    SEISCOMP_SUCCESS = _Core.Status_SEISCOMP_SUCCESS
    SEISCOMP_FAILURE = _Core.Status_SEISCOMP_FAILURE
    SEISCOMP_INVALID_GROUP_ERROR = _Core.Status_SEISCOMP_INVALID_GROUP_ERROR
    SEISCOMP_INVALID_CLIENT_NAME_ERROR = _Core.Status_SEISCOMP_INVALID_CLIENT_NAME_ERROR
    SEISCOMP_TIMEOUT_ERROR = _Core.Status_SEISCOMP_TIMEOUT_ERROR
    SEISCOMP_MESSAGE_SIZE_ERROR = _Core.Status_SEISCOMP_MESSAGE_SIZE_ERROR
    SEISCOMP_ARCHIVE_REQUEST_ERROR = _Core.Status_SEISCOMP_ARCHIVE_REQUEST_ERROR
    SEISCOMP_CONNECT_ERROR = _Core.Status_SEISCOMP_CONNECT_ERROR
    SEISCOMP_NETWORKING_ERROR = _Core.Status_SEISCOMP_NETWORKING_ERROR
    SEISCOMP_NOT_CONNECTED_ERROR = _Core.Status_SEISCOMP_NOT_CONNECTED_ERROR
    SEISCOMP_CLIENT_NAME_NOT_UNIQUE = _Core.Status_SEISCOMP_CLIENT_NAME_NOT_UNIQUE
    SEISCOMP_WRONG_SERVER_VERSION = _Core.Status_SEISCOMP_WRONG_SERVER_VERSION
    SEISCOMP_TOO_MANY_USERS = _Core.Status_SEISCOMP_TOO_MANY_USERS
    SC_QUANTITY = _Core.Status_SC_QUANTITY
    if _newclass:
        StatusToStr = staticmethod(_Core.Status_StatusToStr)
    else:
        StatusToStr = _Core.Status_StatusToStr
    __swig_destroy__ = _Core.delete_Status
    __del__ = lambda self: None
Status_swigregister = _Core.Status_swigregister
Status_swigregister(Status)

def Status_StatusToStr(statusCode):
    return _Core.Status_StatusToStr(statusCode)
Status_StatusToStr = _Core.Status_StatusToStr

class Array(BaseObject):
    __swig_setmethods__ = {}
    for _s in [BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Array, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Array, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.Array_ClassName)
    else:
        ClassName = _Core.Array_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.Array_TypeInfo)
    else:
        TypeInfo = _Core.Array_TypeInfo

    def className(self):
        return _Core.Array_className(self)

    def typeInfo(self):
        return _Core.Array_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.Array_Cast)
    else:
        Cast = _Core.Array_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.Array_ConstCast)
    else:
        ConstCast = _Core.Array_ConstCast
    CHAR = _Core.Array_CHAR
    INT = _Core.Array_INT
    FLOAT = _Core.Array_FLOAT
    DOUBLE = _Core.Array_DOUBLE
    DATETIME = _Core.Array_DATETIME
    STRING = _Core.Array_STRING
    COMPLEX_FLOAT = _Core.Array_COMPLEX_FLOAT
    COMPLEX_DOUBLE = _Core.Array_COMPLEX_DOUBLE
    DT_QUANTITY = _Core.Array_DT_QUANTITY
    __swig_destroy__ = _Core.delete_Array
    __del__ = lambda self: None

    def dataType(self):
        return _Core.Array_dataType(self)

    def clone(self):
        return _Core.Array_clone(self)

    def copy(self, dt):
        return _Core.Array_copy(self, dt)

    def data(self):
        return _Core.Array_data(self)

    def size(self):
        return _Core.Array_size(self)

    def resize(self, size):
        return _Core.Array_resize(self, size)

    def clear(self):
        return _Core.Array_clear(self)

    def elementSize(self):
        return _Core.Array_elementSize(self)

    def append(self, arg2):
        return _Core.Array_append(self, arg2)

    def slice(self, m, n):
        return _Core.Array_slice(self, m, n)

    def str(self):
        return _Core.Array_str(self)

    def numpy(self):
        return _Core.Array_numpy(self)

    def setNumpy(self, obj):
        return _Core.Array_setNumpy(self, obj)

    def bytes(self):
        return _Core.Array_bytes(self)

    def str(self):
    	""" For backwards compatibility """
    	return self.bytes()

    def __str__(self):
    	""" For backwards compatibility """
    	return self.bytes()

    def __bytes__(self):
    	return self.bytes()

    def numeric(self):
    	import sys
    	sys.stderr.write("Use of Array.numeric() is deprecated - use numpy() instead\n")
    	return self.numpy()

Array_swigregister = _Core.Array_swigregister
Array_swigregister(Array)

def Array_ClassName():
    return _Core.Array_ClassName()
Array_ClassName = _Core.Array_ClassName

def Array_TypeInfo():
    return _Core.Array_TypeInfo()
Array_TypeInfo = _Core.Array_TypeInfo

def Array_Cast(*args):
    return _Core.Array_Cast(*args)
Array_Cast = _Core.Array_Cast

def Array_ConstCast(*args):
    return _Core.Array_ConstCast(*args)
Array_ConstCast = _Core.Array_ConstCast

class BitSet(BaseObject):
    __swig_setmethods__ = {}
    for _s in [BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BitSet, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BitSet, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.BitSet_ClassName)
    else:
        ClassName = _Core.BitSet_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.BitSet_TypeInfo)
    else:
        TypeInfo = _Core.BitSet_TypeInfo

    def className(self):
        return _Core.BitSet_className(self)

    def typeInfo(self):
        return _Core.BitSet_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.BitSet_Cast)
    else:
        Cast = _Core.BitSet_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.BitSet_ConstCast)
    else:
        ConstCast = _Core.BitSet_ConstCast

    def __init__(self, *args):
        this = _Core.new_BitSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __iand__(self, b):
        return _Core.BitSet___iand__(self, b)

    def __ior__(self, b):
        return _Core.BitSet___ior__(self, b)

    def __ixor__(self, b):
        return _Core.BitSet___ixor__(self, b)

    def __isub__(self, b):
        return _Core.BitSet___isub__(self, b)

    def __ilshift__(self, n):
        return _Core.BitSet___ilshift__(self, n)

    def __irshift__(self, n):
        return _Core.BitSet___irshift__(self, n)

    def __lshift__(self, n):
        return _Core.BitSet___lshift__(self, n)

    def __rshift__(self, n):
        return _Core.BitSet___rshift__(self, n)

    def __invert__(self):
        return _Core.BitSet___invert__(self)

    def resize(self, num_bits, value=False):
        return _Core.BitSet_resize(self, num_bits, value)

    def clear(self):
        return _Core.BitSet_clear(self)

    def append(self, bit):
        return _Core.BitSet_append(self, bit)

    def set(self, *args):
        return _Core.BitSet_set(self, *args)

    def reset(self, *args):
        return _Core.BitSet_reset(self, *args)

    def flip(self, *args):
        return _Core.BitSet_flip(self, *args)

    def test(self, n):
        return _Core.BitSet_test(self, n)

    def any(self):
        return _Core.BitSet_any(self)

    def none(self):
        return _Core.BitSet_none(self)

    def numberOfBitsSet(self):
        return _Core.BitSet_numberOfBitsSet(self)

    def toUlong(self):
        return _Core.BitSet_toUlong(self)

    def size(self):
        return _Core.BitSet_size(self)

    def numberOfBlocks(self):
        return _Core.BitSet_numberOfBlocks(self)

    def maximumSize(self):
        return _Core.BitSet_maximumSize(self)

    def empty(self):
        return _Core.BitSet_empty(self)

    def findFirst(self):
        return _Core.BitSet_findFirst(self)

    def findNext(self, pos):
        return _Core.BitSet_findNext(self, pos)

    def impl(self, *args):
        return _Core.BitSet_impl(self, *args)
    __swig_destroy__ = _Core.delete_BitSet
    __del__ = lambda self: None
BitSet_swigregister = _Core.BitSet_swigregister
BitSet_swigregister(BitSet)

def BitSet_ClassName():
    return _Core.BitSet_ClassName()
BitSet_ClassName = _Core.BitSet_ClassName

def BitSet_TypeInfo():
    return _Core.BitSet_TypeInfo()
BitSet_TypeInfo = _Core.BitSet_TypeInfo

def BitSet_Cast(*args):
    return _Core.BitSet_Cast(*args)
BitSet_Cast = _Core.BitSet_Cast

def BitSet_ConstCast(*args):
    return _Core.BitSet_ConstCast(*args)
BitSet_ConstCast = _Core.BitSet_ConstCast

class Record(BaseObject):
    __swig_setmethods__ = {}
    for _s in [BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Record, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Record, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.Record_ClassName)
    else:
        ClassName = _Core.Record_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.Record_TypeInfo)
    else:
        TypeInfo = _Core.Record_TypeInfo

    def className(self):
        return _Core.Record_className(self)

    def typeInfo(self):
        return _Core.Record_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.Record_Cast)
    else:
        Cast = _Core.Record_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.Record_ConstCast)
    else:
        ConstCast = _Core.Record_ConstCast

    def serialize(self, ar):
        return _Core.Record_serialize(self, ar)
    META_ONLY = _Core.Record_META_ONLY
    DATA_ONLY = _Core.Record_DATA_ONLY
    SAVE_RAW = _Core.Record_SAVE_RAW
    H_QUANTITY = _Core.Record_H_QUANTITY
    NOT_SIGNED = _Core.Record_NOT_SIGNED
    SIGNATURE_VALIDATED = _Core.Record_SIGNATURE_VALIDATED
    SIGNATURE_VALIDATION_FAILED = _Core.Record_SIGNATURE_VALIDATION_FAILED
    A_QUANTITY = _Core.Record_A_QUANTITY
    __swig_destroy__ = _Core.delete_Record
    __del__ = lambda self: None

    def networkCode(self):
        return _Core.Record_networkCode(self)

    def setNetworkCode(self, net):
        return _Core.Record_setNetworkCode(self, net)

    def stationCode(self):
        return _Core.Record_stationCode(self)

    def setStationCode(self, sta):
        return _Core.Record_setStationCode(self, sta)

    def locationCode(self):
        return _Core.Record_locationCode(self)

    def setLocationCode(self, loc):
        return _Core.Record_setLocationCode(self, loc)

    def channelCode(self):
        return _Core.Record_channelCode(self)

    def setChannelCode(self, cha):
        return _Core.Record_setChannelCode(self, cha)

    def startTime(self):
        return _Core.Record_startTime(self)

    def setStartTime(self, time):
        return _Core.Record_setStartTime(self, time)

    def endTime(self):
        return _Core.Record_endTime(self)

    def timeWindow(self):
        return _Core.Record_timeWindow(self)

    def sampleCount(self):
        return _Core.Record_sampleCount(self)

    def samplingFrequency(self):
        return _Core.Record_samplingFrequency(self)

    def timingQuality(self):
        return _Core.Record_timingQuality(self)

    def setTimingQuality(self, tqual):
        return _Core.Record_setTimingQuality(self, tqual)

    def streamID(self):
        return _Core.Record_streamID(self)

    def dataType(self):
        return _Core.Record_dataType(self)

    def setDataType(self, dt):
        return _Core.Record_setDataType(self, dt)

    def setHint(self, h):
        return _Core.Record_setHint(self, h)

    def setAuthentication(self, auth):
        return _Core.Record_setAuthentication(self, auth)

    def authentication(self):
        return _Core.Record_authentication(self)

    def setAuthority(self, authority):
        return _Core.Record_setAuthority(self, authority)

    def authority(self):
        return _Core.Record_authority(self)

    def data(self):
        return _Core.Record_data(self)

    def raw(self):
        return _Core.Record_raw(self)

    def copy(self):
        return _Core.Record_copy(self)

    def clipMask(self):
        return _Core.Record_clipMask(self)

    def saveSpace(self):
        return _Core.Record_saveSpace(self)

    def read(self, arg2):
        return _Core.Record_read(self, arg2)

    def write(self, out):
        return _Core.Record_write(self, out)
Record_swigregister = _Core.Record_swigregister
Record_swigregister(Record)

def Record_ClassName():
    return _Core.Record_ClassName()
Record_ClassName = _Core.Record_ClassName

def Record_TypeInfo():
    return _Core.Record_TypeInfo()
Record_TypeInfo = _Core.Record_TypeInfo

def Record_Cast(*args):
    return _Core.Record_Cast(*args)
Record_Cast = _Core.Record_Cast

def Record_ConstCast(*args):
    return _Core.Record_ConstCast(*args)
Record_ConstCast = _Core.Record_ConstCast

ZSS = _Core.ZSS
ZDS = _Core.ZDS
ZDD = _Core.ZDD
RSS = _Core.RSS
RDS = _Core.RDS
RDD = _Core.RDD
TSS = _Core.TSS
TDS = _Core.TDS
ZEP = _Core.ZEP
REP = _Core.REP
EGreensFunctionComponentQuantity = _Core.EGreensFunctionComponentQuantity
class EGreensFunctionComponentNames(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EGreensFunctionComponentNames, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EGreensFunctionComponentNames, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _Core.new_EGreensFunctionComponentNames()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        name = staticmethod(_Core.EGreensFunctionComponentNames_name)
    else:
        name = _Core.EGreensFunctionComponentNames_name
    __swig_destroy__ = _Core.delete_EGreensFunctionComponentNames
    __del__ = lambda self: None
EGreensFunctionComponentNames_swigregister = _Core.EGreensFunctionComponentNames_swigregister
EGreensFunctionComponentNames_swigregister(EGreensFunctionComponentNames)

def EGreensFunctionComponentNames_name(i):
    return _Core.EGreensFunctionComponentNames_name(i)
EGreensFunctionComponentNames_name = _Core.EGreensFunctionComponentNames_name

class GreensFunction(BaseObject):
    __swig_setmethods__ = {}
    for _s in [BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GreensFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GreensFunction, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.GreensFunction_ClassName)
    else:
        ClassName = _Core.GreensFunction_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.GreensFunction_TypeInfo)
    else:
        TypeInfo = _Core.GreensFunction_TypeInfo

    def className(self):
        return _Core.GreensFunction_className(self)

    def typeInfo(self):
        return _Core.GreensFunction_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.GreensFunction_Cast)
    else:
        Cast = _Core.GreensFunction_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.GreensFunction_ConstCast)
    else:
        ConstCast = _Core.GreensFunction_ConstCast

    def serialize(self, ar):
        return _Core.GreensFunction_serialize(self, ar)

    def __init__(self, *args):
        this = _Core.new_GreensFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_GreensFunction
    __del__ = lambda self: None

    def setId(self, id):
        return _Core.GreensFunction_setId(self, id)

    def id(self):
        return _Core.GreensFunction_id(self)

    def setModel(self, model):
        return _Core.GreensFunction_setModel(self, model)

    def model(self):
        return _Core.GreensFunction_model(self)

    def setDistance(self, arg2):
        return _Core.GreensFunction_setDistance(self, arg2)

    def distance(self):
        return _Core.GreensFunction_distance(self)

    def setDepth(self, arg2):
        return _Core.GreensFunction_setDepth(self, arg2)

    def depth(self):
        return _Core.GreensFunction_depth(self)

    def setSamplingFrequency(self, arg2):
        return _Core.GreensFunction_setSamplingFrequency(self, arg2)

    def samplingFrequency(self):
        return _Core.GreensFunction_samplingFrequency(self)

    def setTimeOffset(self, arg2):
        return _Core.GreensFunction_setTimeOffset(self, arg2)

    def timeOffset(self):
        return _Core.GreensFunction_timeOffset(self)

    def length(self, arg2):
        return _Core.GreensFunction_length(self, arg2)

    def data(self, arg2):
        return _Core.GreensFunction_data(self, arg2)

    def setData(self, *args):
        return _Core.GreensFunction_setData(self, *args)
GreensFunction_swigregister = _Core.GreensFunction_swigregister
GreensFunction_swigregister(GreensFunction)

def GreensFunction_ClassName():
    return _Core.GreensFunction_ClassName()
GreensFunction_ClassName = _Core.GreensFunction_ClassName

def GreensFunction_TypeInfo():
    return _Core.GreensFunction_TypeInfo()
GreensFunction_TypeInfo = _Core.GreensFunction_TypeInfo

def GreensFunction_Cast(*args):
    return _Core.GreensFunction_Cast(*args)
GreensFunction_Cast = _Core.GreensFunction_Cast

def GreensFunction_ConstCast(*args):
    return _Core.GreensFunction_ConstCast(*args)
GreensFunction_ConstCast = _Core.GreensFunction_ConstCast

class GenericRecord(Record):
    __swig_setmethods__ = {}
    for _s in [Record]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericRecord, name, value)
    __swig_getmethods__ = {}
    for _s in [Record]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenericRecord, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.GenericRecord_ClassName)
    else:
        ClassName = _Core.GenericRecord_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.GenericRecord_TypeInfo)
    else:
        TypeInfo = _Core.GenericRecord_TypeInfo

    def className(self):
        return _Core.GenericRecord_className(self)

    def typeInfo(self):
        return _Core.GenericRecord_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.GenericRecord_Cast)
    else:
        Cast = _Core.GenericRecord_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.GenericRecord_ConstCast)
    else:
        ConstCast = _Core.GenericRecord_ConstCast

    def serialize(self, ar):
        return _Core.GenericRecord_serialize(self, ar)

    def __init__(self, *args):
        this = _Core.new_GenericRecord(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_GenericRecord
    __del__ = lambda self: None

    def setSamplingFrequency(self, freq):
        return _Core.GenericRecord_setSamplingFrequency(self, freq)

    def data(self, *args):
        return _Core.GenericRecord_data(self, *args)

    def raw(self):
        return _Core.GenericRecord_raw(self)

    def clipMask(self):
        return _Core.GenericRecord_clipMask(self)

    def setData(self, *args):
        return _Core.GenericRecord_setData(self, *args)

    def setClipMask(self, clipMask):
        return _Core.GenericRecord_setClipMask(self, clipMask)

    def dataUpdated(self):
        return _Core.GenericRecord_dataUpdated(self)

    def saveSpace(self):
        return _Core.GenericRecord_saveSpace(self)

    def copy(self):
        return _Core.GenericRecord_copy(self)

    def read(self, arg2):
        return _Core.GenericRecord_read(self, arg2)

    def write(self, out):
        return _Core.GenericRecord_write(self, out)
GenericRecord_swigregister = _Core.GenericRecord_swigregister
GenericRecord_swigregister(GenericRecord)

def GenericRecord_ClassName():
    return _Core.GenericRecord_ClassName()
GenericRecord_ClassName = _Core.GenericRecord_ClassName

def GenericRecord_TypeInfo():
    return _Core.GenericRecord_TypeInfo()
GenericRecord_TypeInfo = _Core.GenericRecord_TypeInfo

def GenericRecord_Cast(*args):
    return _Core.GenericRecord_Cast(*args)
GenericRecord_Cast = _Core.GenericRecord_Cast

def GenericRecord_ConstCast(*args):
    return _Core.GenericRecord_ConstCast(*args)
GenericRecord_ConstCast = _Core.GenericRecord_ConstCast

class MessageIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MessageIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MessageIterator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Core.new_MessageIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_MessageIterator
    __del__ = lambda self: None

    def get(self):
        return _Core.MessageIterator_get(self)

    def __ref__(self):
        return _Core.MessageIterator___ref__(self)

    def step(self):
        return _Core.MessageIterator_step(self)

    def __next__(self):
    	o = self.get()
    	if not o:
    		raise StopIteration

    	self.step()
    	return o

    # for Python 2 compatibility
    def next(self):
    	return self.__next__()

MessageIterator_swigregister = _Core.MessageIterator_swigregister
MessageIterator_swigregister(MessageIterator)

class Message(BaseObject):
    __swig_setmethods__ = {}
    for _s in [BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Message, name, value)
    __swig_getmethods__ = {}
    for _s in [BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Message, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.Message_ClassName)
    else:
        ClassName = _Core.Message_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.Message_TypeInfo)
    else:
        TypeInfo = _Core.Message_TypeInfo

    def className(self):
        return _Core.Message_className(self)

    def typeInfo(self):
        return _Core.Message_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.Message_Cast)
    else:
        Cast = _Core.Message_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.Message_ConstCast)
    else:
        ConstCast = _Core.Message_ConstCast

    def serialize(self, ar):
        return _Core.Message_serialize(self, ar)
    __swig_destroy__ = _Core.delete_Message
    __del__ = lambda self: None

    def iter(self):
        return _Core.Message_iter(self)

    def size(self):
        return _Core.Message_size(self)

    def empty(self):
        return _Core.Message_empty(self)

    def clear(self):
        return _Core.Message_clear(self)

    def setDataSize(self, size):
        return _Core.Message_setDataSize(self, size)

    def dataSize(self):
        return _Core.Message_dataSize(self)

    def __iter__(self):
    	return self.iter()

Message_swigregister = _Core.Message_swigregister
Message_swigregister(Message)

def Message_ClassName():
    return _Core.Message_ClassName()
Message_ClassName = _Core.Message_ClassName

def Message_TypeInfo():
    return _Core.Message_TypeInfo()
Message_TypeInfo = _Core.Message_TypeInfo

def Message_Cast(*args):
    return _Core.Message_Cast(*args)
Message_Cast = _Core.Message_Cast

def Message_ConstCast(*args):
    return _Core.Message_ConstCast(*args)
Message_ConstCast = _Core.Message_ConstCast

class DataMessageBase(Message):
    __swig_setmethods__ = {}
    for _s in [Message]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataMessageBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Message]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataMessageBase, name)
    __repr__ = _swig_repr

    def serialize(self, ar):
        return _Core.DataMessageBase_serialize(self, ar)

    def __init__(self):
        this = _Core.new_DataMessageBase()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_DataMessageBase
    __del__ = lambda self: None

    def attach(self, *args):
        return _Core.DataMessageBase_attach(self, *args)

    def detach(self, *args):
        return _Core.DataMessageBase_detach(self, *args)

    def clear(self):
        return _Core.DataMessageBase_clear(self)

    def begin(self, *args):
        return _Core.DataMessageBase_begin(self, *args)

    def end(self, *args):
        return _Core.DataMessageBase_end(self, *args)

    def empty(self):
        return _Core.DataMessageBase_empty(self)

    def size(self):
        return _Core.DataMessageBase_size(self)
DataMessageBase_swigregister = _Core.DataMessageBase_swigregister
DataMessageBase_swigregister(DataMessageBase)

class DataMessage(DataMessageBase):
    __swig_setmethods__ = {}
    for _s in [DataMessageBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataMessage, name, value)
    __swig_getmethods__ = {}
    for _s in [DataMessageBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DataMessage, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.DataMessage_ClassName)
    else:
        ClassName = _Core.DataMessage_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.DataMessage_TypeInfo)
    else:
        TypeInfo = _Core.DataMessage_TypeInfo

    def className(self):
        return _Core.DataMessage_className(self)

    def typeInfo(self):
        return _Core.DataMessage_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.DataMessage_Cast)
    else:
        Cast = _Core.DataMessage_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.DataMessage_ConstCast)
    else:
        ConstCast = _Core.DataMessage_ConstCast

    def __init__(self):
        this = _Core.new_DataMessage()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_DataMessage
    __del__ = lambda self: None
DataMessage_swigregister = _Core.DataMessage_swigregister
DataMessage_swigregister(DataMessage)

def DataMessage_ClassName():
    return _Core.DataMessage_ClassName()
DataMessage_ClassName = _Core.DataMessage_ClassName

def DataMessage_TypeInfo():
    return _Core.DataMessage_TypeInfo()
DataMessage_TypeInfo = _Core.DataMessage_TypeInfo

def DataMessage_Cast(*args):
    return _Core.DataMessage_Cast(*args)
DataMessage_Cast = _Core.DataMessage_Cast

def DataMessage_ConstCast(*args):
    return _Core.DataMessage_ConstCast(*args)
DataMessage_ConstCast = _Core.DataMessage_ConstCast

class CharArrayT(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharArrayT, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharArrayT, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.CharArrayT_ClassName)
    else:
        ClassName = _Core.CharArrayT_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.CharArrayT_TypeInfo)
    else:
        TypeInfo = _Core.CharArrayT_TypeInfo

    def className(self):
        return _Core.CharArrayT_className(self)

    def typeInfo(self):
        return _Core.CharArrayT_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.CharArrayT_Cast)
    else:
        Cast = _Core.CharArrayT_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.CharArrayT_ConstCast)
    else:
        ConstCast = _Core.CharArrayT_ConstCast

    def serialize(self, ar):
        return _Core.CharArrayT_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.CharArrayT_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.CharArrayT_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.CharArrayT_ArrayType_get, _Core.CharArrayT_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_CharArrayT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_CharArrayT
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.CharArrayT_copy(self, dt)

    def setData(self, size, data):
        return _Core.CharArrayT_setData(self, size, data)

    def data(self):
        return _Core.CharArrayT_data(self)

    def typedData(self, *args):
        return _Core.CharArrayT_typedData(self, *args)

    def size(self):
        return _Core.CharArrayT_size(self)

    def elementSize(self):
        return _Core.CharArrayT_elementSize(self)

    def resize(self, size):
        return _Core.CharArrayT_resize(self, size)

    def clear(self):
        return _Core.CharArrayT_clear(self)

    def fill(self, v):
        return _Core.CharArrayT_fill(self, v)

    def set(self, index, v):
        return _Core.CharArrayT_set(self, index, v)

    def get(self, index):
        return _Core.CharArrayT_get(self, index)

    def append(self, *args):
        return _Core.CharArrayT_append(self, *args)

    def prepend(self, *args):
        return _Core.CharArrayT_prepend(self, *args)

    def slice(self, m, n):
        return _Core.CharArrayT_slice(self, m, n)

    def begin(self, *args):
        return _Core.CharArrayT_begin(self, *args)

    def end(self, *args):
        return _Core.CharArrayT_end(self, *args)

    def impl(self, *args):
        return _Core.CharArrayT_impl(self, *args)
CharArrayT_swigregister = _Core.CharArrayT_swigregister
CharArrayT_swigregister(CharArrayT)

def CharArrayT_ClassName():
    return _Core.CharArrayT_ClassName()
CharArrayT_ClassName = _Core.CharArrayT_ClassName

def CharArrayT_TypeInfo():
    return _Core.CharArrayT_TypeInfo()
CharArrayT_TypeInfo = _Core.CharArrayT_TypeInfo

def CharArrayT_Cast(*args):
    return _Core.CharArrayT_Cast(*args)
CharArrayT_Cast = _Core.CharArrayT_Cast

def CharArrayT_ConstCast(*args):
    return _Core.CharArrayT_ConstCast(*args)
CharArrayT_ConstCast = _Core.CharArrayT_ConstCast

class IntArrayT(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntArrayT, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntArrayT, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.IntArrayT_ClassName)
    else:
        ClassName = _Core.IntArrayT_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.IntArrayT_TypeInfo)
    else:
        TypeInfo = _Core.IntArrayT_TypeInfo

    def className(self):
        return _Core.IntArrayT_className(self)

    def typeInfo(self):
        return _Core.IntArrayT_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.IntArrayT_Cast)
    else:
        Cast = _Core.IntArrayT_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.IntArrayT_ConstCast)
    else:
        ConstCast = _Core.IntArrayT_ConstCast

    def serialize(self, ar):
        return _Core.IntArrayT_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.IntArrayT_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.IntArrayT_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.IntArrayT_ArrayType_get, _Core.IntArrayT_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_IntArrayT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_IntArrayT
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.IntArrayT_copy(self, dt)

    def setData(self, size, data):
        return _Core.IntArrayT_setData(self, size, data)

    def data(self):
        return _Core.IntArrayT_data(self)

    def typedData(self, *args):
        return _Core.IntArrayT_typedData(self, *args)

    def size(self):
        return _Core.IntArrayT_size(self)

    def elementSize(self):
        return _Core.IntArrayT_elementSize(self)

    def resize(self, size):
        return _Core.IntArrayT_resize(self, size)

    def clear(self):
        return _Core.IntArrayT_clear(self)

    def fill(self, v):
        return _Core.IntArrayT_fill(self, v)

    def set(self, index, v):
        return _Core.IntArrayT_set(self, index, v)

    def get(self, index):
        return _Core.IntArrayT_get(self, index)

    def append(self, *args):
        return _Core.IntArrayT_append(self, *args)

    def prepend(self, *args):
        return _Core.IntArrayT_prepend(self, *args)

    def slice(self, m, n):
        return _Core.IntArrayT_slice(self, m, n)

    def begin(self, *args):
        return _Core.IntArrayT_begin(self, *args)

    def end(self, *args):
        return _Core.IntArrayT_end(self, *args)

    def impl(self, *args):
        return _Core.IntArrayT_impl(self, *args)
IntArrayT_swigregister = _Core.IntArrayT_swigregister
IntArrayT_swigregister(IntArrayT)

def IntArrayT_ClassName():
    return _Core.IntArrayT_ClassName()
IntArrayT_ClassName = _Core.IntArrayT_ClassName

def IntArrayT_TypeInfo():
    return _Core.IntArrayT_TypeInfo()
IntArrayT_TypeInfo = _Core.IntArrayT_TypeInfo

def IntArrayT_Cast(*args):
    return _Core.IntArrayT_Cast(*args)
IntArrayT_Cast = _Core.IntArrayT_Cast

def IntArrayT_ConstCast(*args):
    return _Core.IntArrayT_ConstCast(*args)
IntArrayT_ConstCast = _Core.IntArrayT_ConstCast

class FloatArrayT(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatArrayT, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatArrayT, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.FloatArrayT_ClassName)
    else:
        ClassName = _Core.FloatArrayT_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.FloatArrayT_TypeInfo)
    else:
        TypeInfo = _Core.FloatArrayT_TypeInfo

    def className(self):
        return _Core.FloatArrayT_className(self)

    def typeInfo(self):
        return _Core.FloatArrayT_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.FloatArrayT_Cast)
    else:
        Cast = _Core.FloatArrayT_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.FloatArrayT_ConstCast)
    else:
        ConstCast = _Core.FloatArrayT_ConstCast

    def serialize(self, ar):
        return _Core.FloatArrayT_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.FloatArrayT_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.FloatArrayT_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.FloatArrayT_ArrayType_get, _Core.FloatArrayT_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_FloatArrayT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_FloatArrayT
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.FloatArrayT_copy(self, dt)

    def setData(self, size, data):
        return _Core.FloatArrayT_setData(self, size, data)

    def data(self):
        return _Core.FloatArrayT_data(self)

    def typedData(self, *args):
        return _Core.FloatArrayT_typedData(self, *args)

    def size(self):
        return _Core.FloatArrayT_size(self)

    def elementSize(self):
        return _Core.FloatArrayT_elementSize(self)

    def resize(self, size):
        return _Core.FloatArrayT_resize(self, size)

    def clear(self):
        return _Core.FloatArrayT_clear(self)

    def fill(self, v):
        return _Core.FloatArrayT_fill(self, v)

    def set(self, index, v):
        return _Core.FloatArrayT_set(self, index, v)

    def get(self, index):
        return _Core.FloatArrayT_get(self, index)

    def append(self, *args):
        return _Core.FloatArrayT_append(self, *args)

    def prepend(self, *args):
        return _Core.FloatArrayT_prepend(self, *args)

    def slice(self, m, n):
        return _Core.FloatArrayT_slice(self, m, n)

    def begin(self, *args):
        return _Core.FloatArrayT_begin(self, *args)

    def end(self, *args):
        return _Core.FloatArrayT_end(self, *args)

    def impl(self, *args):
        return _Core.FloatArrayT_impl(self, *args)
FloatArrayT_swigregister = _Core.FloatArrayT_swigregister
FloatArrayT_swigregister(FloatArrayT)

def FloatArrayT_ClassName():
    return _Core.FloatArrayT_ClassName()
FloatArrayT_ClassName = _Core.FloatArrayT_ClassName

def FloatArrayT_TypeInfo():
    return _Core.FloatArrayT_TypeInfo()
FloatArrayT_TypeInfo = _Core.FloatArrayT_TypeInfo

def FloatArrayT_Cast(*args):
    return _Core.FloatArrayT_Cast(*args)
FloatArrayT_Cast = _Core.FloatArrayT_Cast

def FloatArrayT_ConstCast(*args):
    return _Core.FloatArrayT_ConstCast(*args)
FloatArrayT_ConstCast = _Core.FloatArrayT_ConstCast

class DoubleArrayT(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleArrayT, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleArrayT, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.DoubleArrayT_ClassName)
    else:
        ClassName = _Core.DoubleArrayT_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.DoubleArrayT_TypeInfo)
    else:
        TypeInfo = _Core.DoubleArrayT_TypeInfo

    def className(self):
        return _Core.DoubleArrayT_className(self)

    def typeInfo(self):
        return _Core.DoubleArrayT_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.DoubleArrayT_Cast)
    else:
        Cast = _Core.DoubleArrayT_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.DoubleArrayT_ConstCast)
    else:
        ConstCast = _Core.DoubleArrayT_ConstCast

    def serialize(self, ar):
        return _Core.DoubleArrayT_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.DoubleArrayT_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.DoubleArrayT_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.DoubleArrayT_ArrayType_get, _Core.DoubleArrayT_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_DoubleArrayT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_DoubleArrayT
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.DoubleArrayT_copy(self, dt)

    def setData(self, size, data):
        return _Core.DoubleArrayT_setData(self, size, data)

    def data(self):
        return _Core.DoubleArrayT_data(self)

    def typedData(self, *args):
        return _Core.DoubleArrayT_typedData(self, *args)

    def size(self):
        return _Core.DoubleArrayT_size(self)

    def elementSize(self):
        return _Core.DoubleArrayT_elementSize(self)

    def resize(self, size):
        return _Core.DoubleArrayT_resize(self, size)

    def clear(self):
        return _Core.DoubleArrayT_clear(self)

    def fill(self, v):
        return _Core.DoubleArrayT_fill(self, v)

    def set(self, index, v):
        return _Core.DoubleArrayT_set(self, index, v)

    def get(self, index):
        return _Core.DoubleArrayT_get(self, index)

    def append(self, *args):
        return _Core.DoubleArrayT_append(self, *args)

    def prepend(self, *args):
        return _Core.DoubleArrayT_prepend(self, *args)

    def slice(self, m, n):
        return _Core.DoubleArrayT_slice(self, m, n)

    def begin(self, *args):
        return _Core.DoubleArrayT_begin(self, *args)

    def end(self, *args):
        return _Core.DoubleArrayT_end(self, *args)

    def impl(self, *args):
        return _Core.DoubleArrayT_impl(self, *args)
DoubleArrayT_swigregister = _Core.DoubleArrayT_swigregister
DoubleArrayT_swigregister(DoubleArrayT)

def DoubleArrayT_ClassName():
    return _Core.DoubleArrayT_ClassName()
DoubleArrayT_ClassName = _Core.DoubleArrayT_ClassName

def DoubleArrayT_TypeInfo():
    return _Core.DoubleArrayT_TypeInfo()
DoubleArrayT_TypeInfo = _Core.DoubleArrayT_TypeInfo

def DoubleArrayT_Cast(*args):
    return _Core.DoubleArrayT_Cast(*args)
DoubleArrayT_Cast = _Core.DoubleArrayT_Cast

def DoubleArrayT_ConstCast(*args):
    return _Core.DoubleArrayT_ConstCast(*args)
DoubleArrayT_ConstCast = _Core.DoubleArrayT_ConstCast

class ComplexFloatArray(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexFloatArray, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexFloatArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.ComplexFloatArray_ClassName)
    else:
        ClassName = _Core.ComplexFloatArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.ComplexFloatArray_TypeInfo)
    else:
        TypeInfo = _Core.ComplexFloatArray_TypeInfo

    def className(self):
        return _Core.ComplexFloatArray_className(self)

    def typeInfo(self):
        return _Core.ComplexFloatArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.ComplexFloatArray_Cast)
    else:
        Cast = _Core.ComplexFloatArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.ComplexFloatArray_ConstCast)
    else:
        ConstCast = _Core.ComplexFloatArray_ConstCast

    def serialize(self, ar):
        return _Core.ComplexFloatArray_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.ComplexFloatArray_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.ComplexFloatArray_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.ComplexFloatArray_ArrayType_get, _Core.ComplexFloatArray_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_ComplexFloatArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_ComplexFloatArray
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.ComplexFloatArray_copy(self, dt)

    def setData(self, size, data):
        return _Core.ComplexFloatArray_setData(self, size, data)

    def data(self):
        return _Core.ComplexFloatArray_data(self)

    def typedData(self, *args):
        return _Core.ComplexFloatArray_typedData(self, *args)

    def size(self):
        return _Core.ComplexFloatArray_size(self)

    def elementSize(self):
        return _Core.ComplexFloatArray_elementSize(self)

    def resize(self, size):
        return _Core.ComplexFloatArray_resize(self, size)

    def clear(self):
        return _Core.ComplexFloatArray_clear(self)

    def fill(self, v):
        return _Core.ComplexFloatArray_fill(self, v)

    def set(self, index, v):
        return _Core.ComplexFloatArray_set(self, index, v)

    def get(self, index):
        return _Core.ComplexFloatArray_get(self, index)

    def append(self, *args):
        return _Core.ComplexFloatArray_append(self, *args)

    def prepend(self, *args):
        return _Core.ComplexFloatArray_prepend(self, *args)

    def slice(self, m, n):
        return _Core.ComplexFloatArray_slice(self, m, n)

    def begin(self, *args):
        return _Core.ComplexFloatArray_begin(self, *args)

    def end(self, *args):
        return _Core.ComplexFloatArray_end(self, *args)

    def impl(self, *args):
        return _Core.ComplexFloatArray_impl(self, *args)
ComplexFloatArray_swigregister = _Core.ComplexFloatArray_swigregister
ComplexFloatArray_swigregister(ComplexFloatArray)

def ComplexFloatArray_ClassName():
    return _Core.ComplexFloatArray_ClassName()
ComplexFloatArray_ClassName = _Core.ComplexFloatArray_ClassName

def ComplexFloatArray_TypeInfo():
    return _Core.ComplexFloatArray_TypeInfo()
ComplexFloatArray_TypeInfo = _Core.ComplexFloatArray_TypeInfo

def ComplexFloatArray_Cast(*args):
    return _Core.ComplexFloatArray_Cast(*args)
ComplexFloatArray_Cast = _Core.ComplexFloatArray_Cast

def ComplexFloatArray_ConstCast(*args):
    return _Core.ComplexFloatArray_ConstCast(*args)
ComplexFloatArray_ConstCast = _Core.ComplexFloatArray_ConstCast

class ComplexDoubleArray(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ComplexDoubleArray, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ComplexDoubleArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.ComplexDoubleArray_ClassName)
    else:
        ClassName = _Core.ComplexDoubleArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.ComplexDoubleArray_TypeInfo)
    else:
        TypeInfo = _Core.ComplexDoubleArray_TypeInfo

    def className(self):
        return _Core.ComplexDoubleArray_className(self)

    def typeInfo(self):
        return _Core.ComplexDoubleArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.ComplexDoubleArray_Cast)
    else:
        Cast = _Core.ComplexDoubleArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.ComplexDoubleArray_ConstCast)
    else:
        ConstCast = _Core.ComplexDoubleArray_ConstCast

    def serialize(self, ar):
        return _Core.ComplexDoubleArray_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.ComplexDoubleArray_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.ComplexDoubleArray_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.ComplexDoubleArray_ArrayType_get, _Core.ComplexDoubleArray_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_ComplexDoubleArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_ComplexDoubleArray
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.ComplexDoubleArray_copy(self, dt)

    def setData(self, size, data):
        return _Core.ComplexDoubleArray_setData(self, size, data)

    def data(self):
        return _Core.ComplexDoubleArray_data(self)

    def typedData(self, *args):
        return _Core.ComplexDoubleArray_typedData(self, *args)

    def size(self):
        return _Core.ComplexDoubleArray_size(self)

    def elementSize(self):
        return _Core.ComplexDoubleArray_elementSize(self)

    def resize(self, size):
        return _Core.ComplexDoubleArray_resize(self, size)

    def clear(self):
        return _Core.ComplexDoubleArray_clear(self)

    def fill(self, v):
        return _Core.ComplexDoubleArray_fill(self, v)

    def set(self, index, v):
        return _Core.ComplexDoubleArray_set(self, index, v)

    def get(self, index):
        return _Core.ComplexDoubleArray_get(self, index)

    def append(self, *args):
        return _Core.ComplexDoubleArray_append(self, *args)

    def prepend(self, *args):
        return _Core.ComplexDoubleArray_prepend(self, *args)

    def slice(self, m, n):
        return _Core.ComplexDoubleArray_slice(self, m, n)

    def begin(self, *args):
        return _Core.ComplexDoubleArray_begin(self, *args)

    def end(self, *args):
        return _Core.ComplexDoubleArray_end(self, *args)

    def impl(self, *args):
        return _Core.ComplexDoubleArray_impl(self, *args)
ComplexDoubleArray_swigregister = _Core.ComplexDoubleArray_swigregister
ComplexDoubleArray_swigregister(ComplexDoubleArray)

def ComplexDoubleArray_ClassName():
    return _Core.ComplexDoubleArray_ClassName()
ComplexDoubleArray_ClassName = _Core.ComplexDoubleArray_ClassName

def ComplexDoubleArray_TypeInfo():
    return _Core.ComplexDoubleArray_TypeInfo()
ComplexDoubleArray_TypeInfo = _Core.ComplexDoubleArray_TypeInfo

def ComplexDoubleArray_Cast(*args):
    return _Core.ComplexDoubleArray_Cast(*args)
ComplexDoubleArray_Cast = _Core.ComplexDoubleArray_Cast

def ComplexDoubleArray_ConstCast(*args):
    return _Core.ComplexDoubleArray_ConstCast(*args)
ComplexDoubleArray_ConstCast = _Core.ComplexDoubleArray_ConstCast

class DateTimeArray(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DateTimeArray, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DateTimeArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.DateTimeArray_ClassName)
    else:
        ClassName = _Core.DateTimeArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.DateTimeArray_TypeInfo)
    else:
        TypeInfo = _Core.DateTimeArray_TypeInfo

    def className(self):
        return _Core.DateTimeArray_className(self)

    def typeInfo(self):
        return _Core.DateTimeArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.DateTimeArray_Cast)
    else:
        Cast = _Core.DateTimeArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.DateTimeArray_ConstCast)
    else:
        ConstCast = _Core.DateTimeArray_ConstCast

    def serialize(self, ar):
        return _Core.DateTimeArray_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.DateTimeArray_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.DateTimeArray_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.DateTimeArray_ArrayType_get, _Core.DateTimeArray_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_DateTimeArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_DateTimeArray
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.DateTimeArray_copy(self, dt)

    def setData(self, size, data):
        return _Core.DateTimeArray_setData(self, size, data)

    def data(self):
        return _Core.DateTimeArray_data(self)

    def typedData(self, *args):
        return _Core.DateTimeArray_typedData(self, *args)

    def size(self):
        return _Core.DateTimeArray_size(self)

    def elementSize(self):
        return _Core.DateTimeArray_elementSize(self)

    def resize(self, size):
        return _Core.DateTimeArray_resize(self, size)

    def clear(self):
        return _Core.DateTimeArray_clear(self)

    def fill(self, v):
        return _Core.DateTimeArray_fill(self, v)

    def set(self, index, v):
        return _Core.DateTimeArray_set(self, index, v)

    def get(self, index):
        return _Core.DateTimeArray_get(self, index)

    def append(self, *args):
        return _Core.DateTimeArray_append(self, *args)

    def prepend(self, *args):
        return _Core.DateTimeArray_prepend(self, *args)

    def slice(self, m, n):
        return _Core.DateTimeArray_slice(self, m, n)

    def begin(self, *args):
        return _Core.DateTimeArray_begin(self, *args)

    def end(self, *args):
        return _Core.DateTimeArray_end(self, *args)

    def impl(self, *args):
        return _Core.DateTimeArray_impl(self, *args)
DateTimeArray_swigregister = _Core.DateTimeArray_swigregister
DateTimeArray_swigregister(DateTimeArray)

def DateTimeArray_ClassName():
    return _Core.DateTimeArray_ClassName()
DateTimeArray_ClassName = _Core.DateTimeArray_ClassName

def DateTimeArray_TypeInfo():
    return _Core.DateTimeArray_TypeInfo()
DateTimeArray_TypeInfo = _Core.DateTimeArray_TypeInfo

def DateTimeArray_Cast(*args):
    return _Core.DateTimeArray_Cast(*args)
DateTimeArray_Cast = _Core.DateTimeArray_Cast

def DateTimeArray_ConstCast(*args):
    return _Core.DateTimeArray_ConstCast(*args)
DateTimeArray_ConstCast = _Core.DateTimeArray_ConstCast

class StringArray(Array):
    __swig_setmethods__ = {}
    for _s in [Array]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringArray, name, value)
    __swig_getmethods__ = {}
    for _s in [Array]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.StringArray_ClassName)
    else:
        ClassName = _Core.StringArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.StringArray_TypeInfo)
    else:
        TypeInfo = _Core.StringArray_TypeInfo

    def className(self):
        return _Core.StringArray_className(self)

    def typeInfo(self):
        return _Core.StringArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.StringArray_Cast)
    else:
        Cast = _Core.StringArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.StringArray_ConstCast)
    else:
        ConstCast = _Core.StringArray_ConstCast

    def serialize(self, ar):
        return _Core.StringArray_serialize(self, ar)
    __swig_setmethods__["ArrayType"] = _Core.StringArray_ArrayType_set
    __swig_getmethods__["ArrayType"] = _Core.StringArray_ArrayType_get
    if _newclass:
        ArrayType = _swig_property(_Core.StringArray_ArrayType_get, _Core.StringArray_ArrayType_set)

    def __init__(self, *args):
        this = _Core.new_StringArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_StringArray
    __del__ = lambda self: None

    def copy(self, dt):
        return _Core.StringArray_copy(self, dt)

    def setData(self, size, data):
        return _Core.StringArray_setData(self, size, data)

    def data(self):
        return _Core.StringArray_data(self)

    def typedData(self, *args):
        return _Core.StringArray_typedData(self, *args)

    def size(self):
        return _Core.StringArray_size(self)

    def elementSize(self):
        return _Core.StringArray_elementSize(self)

    def resize(self, size):
        return _Core.StringArray_resize(self, size)

    def clear(self):
        return _Core.StringArray_clear(self)

    def fill(self, v):
        return _Core.StringArray_fill(self, v)

    def set(self, index, v):
        return _Core.StringArray_set(self, index, v)

    def get(self, index):
        return _Core.StringArray_get(self, index)

    def append(self, *args):
        return _Core.StringArray_append(self, *args)

    def prepend(self, *args):
        return _Core.StringArray_prepend(self, *args)

    def slice(self, m, n):
        return _Core.StringArray_slice(self, m, n)

    def begin(self, *args):
        return _Core.StringArray_begin(self, *args)

    def end(self, *args):
        return _Core.StringArray_end(self, *args)

    def impl(self, *args):
        return _Core.StringArray_impl(self, *args)
StringArray_swigregister = _Core.StringArray_swigregister
StringArray_swigregister(StringArray)

def StringArray_ClassName():
    return _Core.StringArray_ClassName()
StringArray_ClassName = _Core.StringArray_ClassName

def StringArray_TypeInfo():
    return _Core.StringArray_TypeInfo()
StringArray_TypeInfo = _Core.StringArray_TypeInfo

def StringArray_Cast(*args):
    return _Core.StringArray_Cast(*args)
StringArray_Cast = _Core.StringArray_Cast

def StringArray_ConstCast(*args):
    return _Core.StringArray_ConstCast(*args)
StringArray_ConstCast = _Core.StringArray_ConstCast

class CharArray(CharArrayT):
    __swig_setmethods__ = {}
    for _s in [CharArrayT]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CharArrayT]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.CharArray_ClassName)
    else:
        ClassName = _Core.CharArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.CharArray_TypeInfo)
    else:
        TypeInfo = _Core.CharArray_TypeInfo

    def className(self):
        return _Core.CharArray_className(self)

    def typeInfo(self):
        return _Core.CharArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.CharArray_Cast)
    else:
        Cast = _Core.CharArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.CharArray_ConstCast)
    else:
        ConstCast = _Core.CharArray_ConstCast

    def __init__(self, *args):
        this = _Core.new_CharArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_CharArray
    __del__ = lambda self: None

    def max(self):
        return _Core.CharArray_max(self)

    def firstMax(self):
        return _Core.CharArray_firstMax(self)

    def absMax(self):
        return _Core.CharArray_absMax(self)

    def min(self):
        return _Core.CharArray_min(self)

    def median(self):
        return _Core.CharArray_median(self)

    def mean(self):
        return _Core.CharArray_mean(self)

    def rms(self, offset=0):
        return _Core.CharArray_rms(self, offset)

    def slice(self, m, n):
        return _Core.CharArray_slice(self, m, n)

    def __iadd__(self, v):
        return _Core.CharArray___iadd__(self, v)

    def __isub__(self, v):
        return _Core.CharArray___isub__(self, v)

    def __imul__(self, v):
        return _Core.CharArray___imul__(self, v)

    def __itruediv__(self, *args):
        return _Core.CharArray___itruediv__(self, *args)
    __idiv__ = __itruediv__


CharArray_swigregister = _Core.CharArray_swigregister
CharArray_swigregister(CharArray)

def CharArray_ClassName():
    return _Core.CharArray_ClassName()
CharArray_ClassName = _Core.CharArray_ClassName

def CharArray_TypeInfo():
    return _Core.CharArray_TypeInfo()
CharArray_TypeInfo = _Core.CharArray_TypeInfo

def CharArray_Cast(*args):
    return _Core.CharArray_Cast(*args)
CharArray_Cast = _Core.CharArray_Cast

def CharArray_ConstCast(*args):
    return _Core.CharArray_ConstCast(*args)
CharArray_ConstCast = _Core.CharArray_ConstCast

class IntArray(IntArrayT):
    __swig_setmethods__ = {}
    for _s in [IntArrayT]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [IntArrayT]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.IntArray_ClassName)
    else:
        ClassName = _Core.IntArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.IntArray_TypeInfo)
    else:
        TypeInfo = _Core.IntArray_TypeInfo

    def className(self):
        return _Core.IntArray_className(self)

    def typeInfo(self):
        return _Core.IntArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.IntArray_Cast)
    else:
        Cast = _Core.IntArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.IntArray_ConstCast)
    else:
        ConstCast = _Core.IntArray_ConstCast

    def __init__(self, *args):
        this = _Core.new_IntArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_IntArray
    __del__ = lambda self: None

    def max(self):
        return _Core.IntArray_max(self)

    def firstMax(self):
        return _Core.IntArray_firstMax(self)

    def absMax(self):
        return _Core.IntArray_absMax(self)

    def min(self):
        return _Core.IntArray_min(self)

    def median(self):
        return _Core.IntArray_median(self)

    def mean(self):
        return _Core.IntArray_mean(self)

    def rms(self, offset=0):
        return _Core.IntArray_rms(self, offset)

    def slice(self, m, n):
        return _Core.IntArray_slice(self, m, n)

    def __iadd__(self, v):
        return _Core.IntArray___iadd__(self, v)

    def __isub__(self, v):
        return _Core.IntArray___isub__(self, v)

    def __imul__(self, v):
        return _Core.IntArray___imul__(self, v)

    def __itruediv__(self, *args):
        return _Core.IntArray___itruediv__(self, *args)
    __idiv__ = __itruediv__


IntArray_swigregister = _Core.IntArray_swigregister
IntArray_swigregister(IntArray)

def IntArray_ClassName():
    return _Core.IntArray_ClassName()
IntArray_ClassName = _Core.IntArray_ClassName

def IntArray_TypeInfo():
    return _Core.IntArray_TypeInfo()
IntArray_TypeInfo = _Core.IntArray_TypeInfo

def IntArray_Cast(*args):
    return _Core.IntArray_Cast(*args)
IntArray_Cast = _Core.IntArray_Cast

def IntArray_ConstCast(*args):
    return _Core.IntArray_ConstCast(*args)
IntArray_ConstCast = _Core.IntArray_ConstCast

class FloatArray(FloatArrayT):
    __swig_setmethods__ = {}
    for _s in [FloatArrayT]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatArray, name, value)
    __swig_getmethods__ = {}
    for _s in [FloatArrayT]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.FloatArray_ClassName)
    else:
        ClassName = _Core.FloatArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.FloatArray_TypeInfo)
    else:
        TypeInfo = _Core.FloatArray_TypeInfo

    def className(self):
        return _Core.FloatArray_className(self)

    def typeInfo(self):
        return _Core.FloatArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.FloatArray_Cast)
    else:
        Cast = _Core.FloatArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.FloatArray_ConstCast)
    else:
        ConstCast = _Core.FloatArray_ConstCast

    def __init__(self, *args):
        this = _Core.new_FloatArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_FloatArray
    __del__ = lambda self: None

    def max(self):
        return _Core.FloatArray_max(self)

    def firstMax(self):
        return _Core.FloatArray_firstMax(self)

    def absMax(self):
        return _Core.FloatArray_absMax(self)

    def min(self):
        return _Core.FloatArray_min(self)

    def median(self):
        return _Core.FloatArray_median(self)

    def mean(self):
        return _Core.FloatArray_mean(self)

    def rms(self, offset=0):
        return _Core.FloatArray_rms(self, offset)

    def slice(self, m, n):
        return _Core.FloatArray_slice(self, m, n)

    def __iadd__(self, v):
        return _Core.FloatArray___iadd__(self, v)

    def __isub__(self, v):
        return _Core.FloatArray___isub__(self, v)

    def __imul__(self, v):
        return _Core.FloatArray___imul__(self, v)

    def __itruediv__(self, *args):
        return _Core.FloatArray___itruediv__(self, *args)
    __idiv__ = __itruediv__


FloatArray_swigregister = _Core.FloatArray_swigregister
FloatArray_swigregister(FloatArray)

def FloatArray_ClassName():
    return _Core.FloatArray_ClassName()
FloatArray_ClassName = _Core.FloatArray_ClassName

def FloatArray_TypeInfo():
    return _Core.FloatArray_TypeInfo()
FloatArray_TypeInfo = _Core.FloatArray_TypeInfo

def FloatArray_Cast(*args):
    return _Core.FloatArray_Cast(*args)
FloatArray_Cast = _Core.FloatArray_Cast

def FloatArray_ConstCast(*args):
    return _Core.FloatArray_ConstCast(*args)
FloatArray_ConstCast = _Core.FloatArray_ConstCast

class DoubleArray(DoubleArrayT):
    __swig_setmethods__ = {}
    for _s in [DoubleArrayT]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleArray, name, value)
    __swig_getmethods__ = {}
    for _s in [DoubleArrayT]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleArray, name)
    __repr__ = _swig_repr
    if _newclass:
        ClassName = staticmethod(_Core.DoubleArray_ClassName)
    else:
        ClassName = _Core.DoubleArray_ClassName
    if _newclass:
        TypeInfo = staticmethod(_Core.DoubleArray_TypeInfo)
    else:
        TypeInfo = _Core.DoubleArray_TypeInfo

    def className(self):
        return _Core.DoubleArray_className(self)

    def typeInfo(self):
        return _Core.DoubleArray_typeInfo(self)
    if _newclass:
        Cast = staticmethod(_Core.DoubleArray_Cast)
    else:
        Cast = _Core.DoubleArray_Cast
    if _newclass:
        ConstCast = staticmethod(_Core.DoubleArray_ConstCast)
    else:
        ConstCast = _Core.DoubleArray_ConstCast

    def __init__(self, *args):
        this = _Core.new_DoubleArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Core.delete_DoubleArray
    __del__ = lambda self: None

    def max(self):
        return _Core.DoubleArray_max(self)

    def firstMax(self):
        return _Core.DoubleArray_firstMax(self)

    def absMax(self):
        return _Core.DoubleArray_absMax(self)

    def min(self):
        return _Core.DoubleArray_min(self)

    def median(self):
        return _Core.DoubleArray_median(self)

    def mean(self):
        return _Core.DoubleArray_mean(self)

    def rms(self, offset=0):
        return _Core.DoubleArray_rms(self, offset)

    def slice(self, m, n):
        return _Core.DoubleArray_slice(self, m, n)

    def __iadd__(self, v):
        return _Core.DoubleArray___iadd__(self, v)

    def __isub__(self, v):
        return _Core.DoubleArray___isub__(self, v)

    def __imul__(self, v):
        return _Core.DoubleArray___imul__(self, v)

    def __itruediv__(self, *args):
        return _Core.DoubleArray___itruediv__(self, *args)
    __idiv__ = __itruediv__


DoubleArray_swigregister = _Core.DoubleArray_swigregister
DoubleArray_swigregister(DoubleArray)

def DoubleArray_ClassName():
    return _Core.DoubleArray_ClassName()
DoubleArray_ClassName = _Core.DoubleArray_ClassName

def DoubleArray_TypeInfo():
    return _Core.DoubleArray_TypeInfo()
DoubleArray_TypeInfo = _Core.DoubleArray_TypeInfo

def DoubleArray_Cast(*args):
    return _Core.DoubleArray_Cast(*args)
DoubleArray_Cast = _Core.DoubleArray_Cast

def DoubleArray_ConstCast(*args):
    return _Core.DoubleArray_ConstCast(*args)
DoubleArray_ConstCast = _Core.DoubleArray_ConstCast

# This file is compatible with both classic and new-style classes.


