# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""Codes for various geographical computations and filters"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Math')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Math')
    _Math = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Math', [dirname(__file__)])
        except ImportError:
            import _Math
            return _Math
        try:
            _mod = imp.load_module('_Math', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Math = swig_import_helper()
    del swig_import_helper
else:
    import _Math
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Math.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _Math.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Math.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Math.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Math.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Math.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Math.SwigPyIterator_copy(self)

    def next(self):
        return _Math.SwigPyIterator_next(self)

    def __next__(self):
        return _Math.SwigPyIterator___next__(self)

    def previous(self):
        return _Math.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Math.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Math.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Math.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Math.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Math.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Math.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Math.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Math.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import seiscomp3.Core
class vectorf(_object):
    """Proxy of C++ std::vector<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorf, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vectorf self) -> SwigPyIterator"""
        return _Math.vectorf_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vectorf self) -> bool"""
        return _Math.vectorf___nonzero__(self)


    def __bool__(self):
        """__bool__(vectorf self) -> bool"""
        return _Math.vectorf___bool__(self)


    def __len__(self):
        """__len__(vectorf self) -> std::vector< float >::size_type"""
        return _Math.vectorf___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vectorf self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> vectorf"""
        return _Math.vectorf___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vectorf self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        __setslice__(vectorf self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, vectorf v)
        """
        return _Math.vectorf___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vectorf self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _Math.vectorf___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vectorf self, std::vector< float >::difference_type i)
        __delitem__(vectorf self, PySliceObject * slice)
        """
        return _Math.vectorf___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vectorf self, PySliceObject * slice) -> vectorf
        __getitem__(vectorf self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _Math.vectorf___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vectorf self, PySliceObject * slice, vectorf v)
        __setitem__(vectorf self, PySliceObject * slice)
        __setitem__(vectorf self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _Math.vectorf___setitem__(self, *args)


    def pop(self):
        """pop(vectorf self) -> std::vector< float >::value_type"""
        return _Math.vectorf_pop(self)


    def append(self, x):
        """append(vectorf self, std::vector< float >::value_type const & x)"""
        return _Math.vectorf_append(self, x)


    def empty(self):
        """empty(vectorf self) -> bool"""
        return _Math.vectorf_empty(self)


    def size(self):
        """size(vectorf self) -> std::vector< float >::size_type"""
        return _Math.vectorf_size(self)


    def swap(self, v):
        """swap(vectorf self, vectorf v)"""
        return _Math.vectorf_swap(self, v)


    def begin(self):
        """begin(vectorf self) -> std::vector< float >::iterator"""
        return _Math.vectorf_begin(self)


    def end(self):
        """end(vectorf self) -> std::vector< float >::iterator"""
        return _Math.vectorf_end(self)


    def rbegin(self):
        """rbegin(vectorf self) -> std::vector< float >::reverse_iterator"""
        return _Math.vectorf_rbegin(self)


    def rend(self):
        """rend(vectorf self) -> std::vector< float >::reverse_iterator"""
        return _Math.vectorf_rend(self)


    def clear(self):
        """clear(vectorf self)"""
        return _Math.vectorf_clear(self)


    def get_allocator(self):
        """get_allocator(vectorf self) -> std::vector< float >::allocator_type"""
        return _Math.vectorf_get_allocator(self)


    def pop_back(self):
        """pop_back(vectorf self)"""
        return _Math.vectorf_pop_back(self)


    def erase(self, *args):
        """
        erase(vectorf self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(vectorf self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _Math.vectorf_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(float)> self) -> vectorf
        __init__(std::vector<(float)> self, vectorf arg2) -> vectorf
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> vectorf
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> vectorf
        """
        this = _Math.new_vectorf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vectorf self, std::vector< float >::value_type const & x)"""
        return _Math.vectorf_push_back(self, x)


    def front(self):
        """front(vectorf self) -> std::vector< float >::value_type const &"""
        return _Math.vectorf_front(self)


    def back(self):
        """back(vectorf self) -> std::vector< float >::value_type const &"""
        return _Math.vectorf_back(self)


    def assign(self, n, x):
        """assign(vectorf self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _Math.vectorf_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vectorf self, std::vector< float >::size_type new_size)
        resize(vectorf self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _Math.vectorf_resize(self, *args)


    def insert(self, *args):
        """
        insert(vectorf self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(vectorf self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _Math.vectorf_insert(self, *args)


    def reserve(self, n):
        """reserve(vectorf self, std::vector< float >::size_type n)"""
        return _Math.vectorf_reserve(self, n)


    def capacity(self):
        """capacity(vectorf self) -> std::vector< float >::size_type"""
        return _Math.vectorf_capacity(self)

    __swig_destroy__ = _Math.delete_vectorf
    __del__ = lambda self: None
vectorf_swigregister = _Math.vectorf_swigregister
vectorf_swigregister(vectorf)

class vectord(_object):
    """Proxy of C++ std::vector<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vectord self) -> SwigPyIterator"""
        return _Math.vectord_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vectord self) -> bool"""
        return _Math.vectord___nonzero__(self)


    def __bool__(self):
        """__bool__(vectord self) -> bool"""
        return _Math.vectord___bool__(self)


    def __len__(self):
        """__len__(vectord self) -> std::vector< double >::size_type"""
        return _Math.vectord___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vectord self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> vectord"""
        return _Math.vectord___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vectord self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(vectord self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, vectord v)
        """
        return _Math.vectord___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vectord self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _Math.vectord___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vectord self, std::vector< double >::difference_type i)
        __delitem__(vectord self, PySliceObject * slice)
        """
        return _Math.vectord___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vectord self, PySliceObject * slice) -> vectord
        __getitem__(vectord self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _Math.vectord___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vectord self, PySliceObject * slice, vectord v)
        __setitem__(vectord self, PySliceObject * slice)
        __setitem__(vectord self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _Math.vectord___setitem__(self, *args)


    def pop(self):
        """pop(vectord self) -> std::vector< double >::value_type"""
        return _Math.vectord_pop(self)


    def append(self, x):
        """append(vectord self, std::vector< double >::value_type const & x)"""
        return _Math.vectord_append(self, x)


    def empty(self):
        """empty(vectord self) -> bool"""
        return _Math.vectord_empty(self)


    def size(self):
        """size(vectord self) -> std::vector< double >::size_type"""
        return _Math.vectord_size(self)


    def swap(self, v):
        """swap(vectord self, vectord v)"""
        return _Math.vectord_swap(self, v)


    def begin(self):
        """begin(vectord self) -> std::vector< double >::iterator"""
        return _Math.vectord_begin(self)


    def end(self):
        """end(vectord self) -> std::vector< double >::iterator"""
        return _Math.vectord_end(self)


    def rbegin(self):
        """rbegin(vectord self) -> std::vector< double >::reverse_iterator"""
        return _Math.vectord_rbegin(self)


    def rend(self):
        """rend(vectord self) -> std::vector< double >::reverse_iterator"""
        return _Math.vectord_rend(self)


    def clear(self):
        """clear(vectord self)"""
        return _Math.vectord_clear(self)


    def get_allocator(self):
        """get_allocator(vectord self) -> std::vector< double >::allocator_type"""
        return _Math.vectord_get_allocator(self)


    def pop_back(self):
        """pop_back(vectord self)"""
        return _Math.vectord_pop_back(self)


    def erase(self, *args):
        """
        erase(vectord self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(vectord self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _Math.vectord_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> vectord
        __init__(std::vector<(double)> self, vectord arg2) -> vectord
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> vectord
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> vectord
        """
        this = _Math.new_vectord(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vectord self, std::vector< double >::value_type const & x)"""
        return _Math.vectord_push_back(self, x)


    def front(self):
        """front(vectord self) -> std::vector< double >::value_type const &"""
        return _Math.vectord_front(self)


    def back(self):
        """back(vectord self) -> std::vector< double >::value_type const &"""
        return _Math.vectord_back(self)


    def assign(self, n, x):
        """assign(vectord self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _Math.vectord_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vectord self, std::vector< double >::size_type new_size)
        resize(vectord self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _Math.vectord_resize(self, *args)


    def insert(self, *args):
        """
        insert(vectord self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(vectord self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _Math.vectord_insert(self, *args)


    def reserve(self, n):
        """reserve(vectord self, std::vector< double >::size_type n)"""
        return _Math.vectord_reserve(self, n)


    def capacity(self):
        """capacity(vectord self) -> std::vector< double >::size_type"""
        return _Math.vectord_capacity(self)

    __swig_destroy__ = _Math.delete_vectord
    __del__ = lambda self: None
vectord_swigregister = _Math.vectord_swigregister
vectord_swigregister(vectord)


def round(val):
    """round(double val) -> double"""
    return _Math.round(val)
class CoordF(seiscomp3.Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Geo::Coord<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoordF, name, value)
    __swig_getmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoordF, name)
    __repr__ = _swig_repr

    def serialize(self, ar):
        """serialize(CoordF self, GenericArchive ar)"""
        return _Math.CoordF_serialize(self, ar)


    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::Coord<(float)> self) -> CoordF
        __init__(Seiscomp::Math::Geo::Coord<(float)> self, float lat_, float lon_) -> CoordF
        """
        this = _Math.new_CoordF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, lat_, lon_):
        """set(CoordF self, float lat_, float lon_)"""
        return _Math.CoordF_set(self, lat_, lon_)


    def latitude(self):
        """latitude(CoordF self) -> float"""
        return _Math.CoordF_latitude(self)


    def longitude(self):
        """longitude(CoordF self) -> float"""
        return _Math.CoordF_longitude(self)


    def __eq__(self, other):
        """__eq__(CoordF self, CoordF other) -> bool"""
        return _Math.CoordF___eq__(self, other)


    def __ne__(self, other):
        """__ne__(CoordF self, CoordF other) -> bool"""
        return _Math.CoordF___ne__(self, other)

    __swig_setmethods__["lat"] = _Math.CoordF_lat_set
    __swig_getmethods__["lat"] = _Math.CoordF_lat_get
    if _newclass:
        lat = _swig_property(_Math.CoordF_lat_get, _Math.CoordF_lat_set)
    __swig_setmethods__["lon"] = _Math.CoordF_lon_set
    __swig_getmethods__["lon"] = _Math.CoordF_lon_get
    if _newclass:
        lon = _swig_property(_Math.CoordF_lon_get, _Math.CoordF_lon_set)
    __swig_destroy__ = _Math.delete_CoordF
    __del__ = lambda self: None
CoordF_swigregister = _Math.CoordF_swigregister
CoordF_swigregister(CoordF)

class CoordD(seiscomp3.Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Geo::Coord<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoordD, name, value)
    __swig_getmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoordD, name)
    __repr__ = _swig_repr

    def serialize(self, ar):
        """serialize(CoordD self, GenericArchive ar)"""
        return _Math.CoordD_serialize(self, ar)


    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::Coord<(double)> self) -> CoordD
        __init__(Seiscomp::Math::Geo::Coord<(double)> self, double lat_, double lon_) -> CoordD
        """
        this = _Math.new_CoordD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, lat_, lon_):
        """set(CoordD self, double lat_, double lon_)"""
        return _Math.CoordD_set(self, lat_, lon_)


    def latitude(self):
        """latitude(CoordD self) -> double"""
        return _Math.CoordD_latitude(self)


    def longitude(self):
        """longitude(CoordD self) -> double"""
        return _Math.CoordD_longitude(self)


    def __eq__(self, other):
        """__eq__(CoordD self, CoordD other) -> bool"""
        return _Math.CoordD___eq__(self, other)


    def __ne__(self, other):
        """__ne__(CoordD self, CoordD other) -> bool"""
        return _Math.CoordD___ne__(self, other)

    __swig_setmethods__["lat"] = _Math.CoordD_lat_set
    __swig_getmethods__["lat"] = _Math.CoordD_lat_get
    if _newclass:
        lat = _swig_property(_Math.CoordD_lat_get, _Math.CoordD_lat_set)
    __swig_setmethods__["lon"] = _Math.CoordD_lon_set
    __swig_getmethods__["lon"] = _Math.CoordD_lon_get
    if _newclass:
        lon = _swig_property(_Math.CoordD_lon_get, _Math.CoordD_lon_set)
    __swig_destroy__ = _Math.delete_CoordD
    __del__ = lambda self: None
CoordD_swigregister = _Math.CoordD_swigregister
CoordD_swigregister(CoordD)

class NamedCoordF(CoordF):
    """Proxy of C++ Seiscomp::Math::Geo::NamedCoord<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [CoordF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NamedCoordF, name, value)
    __swig_getmethods__ = {}
    for _s in [CoordF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NamedCoordF, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::NamedCoord<(float)> self) -> NamedCoordF
        __init__(Seiscomp::Math::Geo::NamedCoord<(float)> self, std::string const & name, float lat_, float lon_) -> NamedCoordF
        """
        this = _Math.new_NamedCoordF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_NamedCoordF
    __del__ = lambda self: None

    def set(self, *args):
        """
        set(NamedCoordF self, float lat_, float lon_)
        set(NamedCoordF self, std::string const & name, float lat_, float lon_)
        """
        return _Math.NamedCoordF_set(self, *args)


    def setName(self, name):
        """setName(NamedCoordF self, std::string const & name)"""
        return _Math.NamedCoordF_setName(self, name)


    def name(self):
        """name(NamedCoordF self) -> std::string const &"""
        return _Math.NamedCoordF_name(self)


    def serialize(self, ar):
        """serialize(NamedCoordF self, GenericArchive ar)"""
        return _Math.NamedCoordF_serialize(self, ar)

NamedCoordF_swigregister = _Math.NamedCoordF_swigregister
NamedCoordF_swigregister(NamedCoordF)

class NamedCoordD(CoordD):
    """Proxy of C++ Seiscomp::Math::Geo::NamedCoord<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [CoordD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NamedCoordD, name, value)
    __swig_getmethods__ = {}
    for _s in [CoordD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NamedCoordD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::NamedCoord<(double)> self) -> NamedCoordD
        __init__(Seiscomp::Math::Geo::NamedCoord<(double)> self, std::string const & name, double lat_, double lon_) -> NamedCoordD
        """
        this = _Math.new_NamedCoordD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_NamedCoordD
    __del__ = lambda self: None

    def set(self, *args):
        """
        set(NamedCoordD self, double lat_, double lon_)
        set(NamedCoordD self, std::string const & name, double lat_, double lon_)
        """
        return _Math.NamedCoordD_set(self, *args)


    def setName(self, name):
        """setName(NamedCoordD self, std::string const & name)"""
        return _Math.NamedCoordD_setName(self, name)


    def name(self):
        """name(NamedCoordD self) -> std::string const &"""
        return _Math.NamedCoordD_name(self)


    def serialize(self, ar):
        """serialize(NamedCoordD self, GenericArchive ar)"""
        return _Math.NamedCoordD_serialize(self, ar)

NamedCoordD_swigregister = _Math.NamedCoordD_swigregister
NamedCoordD_swigregister(NamedCoordD)

class HotspotListF(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::NamedCoordF)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HotspotListF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HotspotListF, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(HotspotListF self) -> SwigPyIterator"""
        return _Math.HotspotListF_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(HotspotListF self) -> bool"""
        return _Math.HotspotListF___nonzero__(self)


    def __bool__(self):
        """__bool__(HotspotListF self) -> bool"""
        return _Math.HotspotListF___bool__(self)


    def __len__(self):
        """__len__(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type"""
        return _Math.HotspotListF___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type j) -> HotspotListF"""
        return _Math.HotspotListF___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type j)
        __setslice__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type j, HotspotListF v)
        """
        return _Math.HotspotListF___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type j)"""
        return _Math.HotspotListF___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i)
        __delitem__(HotspotListF self, PySliceObject * slice)
        """
        return _Math.HotspotListF___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(HotspotListF self, PySliceObject * slice) -> HotspotListF
        __getitem__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i) -> NamedCoordF
        """
        return _Math.HotspotListF___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(HotspotListF self, PySliceObject * slice, HotspotListF v)
        __setitem__(HotspotListF self, PySliceObject * slice)
        __setitem__(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::difference_type i, NamedCoordF x)
        """
        return _Math.HotspotListF___setitem__(self, *args)


    def pop(self):
        """pop(HotspotListF self) -> NamedCoordF"""
        return _Math.HotspotListF_pop(self)


    def append(self, x):
        """append(HotspotListF self, NamedCoordF x)"""
        return _Math.HotspotListF_append(self, x)


    def empty(self):
        """empty(HotspotListF self) -> bool"""
        return _Math.HotspotListF_empty(self)


    def size(self):
        """size(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type"""
        return _Math.HotspotListF_size(self)


    def swap(self, v):
        """swap(HotspotListF self, HotspotListF v)"""
        return _Math.HotspotListF_swap(self, v)


    def begin(self):
        """begin(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator"""
        return _Math.HotspotListF_begin(self)


    def end(self):
        """end(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator"""
        return _Math.HotspotListF_end(self)


    def rbegin(self):
        """rbegin(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::reverse_iterator"""
        return _Math.HotspotListF_rbegin(self)


    def rend(self):
        """rend(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::reverse_iterator"""
        return _Math.HotspotListF_rend(self)


    def clear(self):
        """clear(HotspotListF self)"""
        return _Math.HotspotListF_clear(self)


    def get_allocator(self):
        """get_allocator(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::allocator_type"""
        return _Math.HotspotListF_get_allocator(self)


    def pop_back(self):
        """pop_back(HotspotListF self)"""
        return _Math.HotspotListF_pop_back(self)


    def erase(self, *args):
        """
        erase(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator pos) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator
        erase(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator first, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator last) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator
        """
        return _Math.HotspotListF_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordF)> self) -> HotspotListF
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordF)> self, HotspotListF arg2) -> HotspotListF
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordF)> self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type size) -> HotspotListF
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordF)> self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type size, NamedCoordF value) -> HotspotListF
        """
        this = _Math.new_HotspotListF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(HotspotListF self, NamedCoordF x)"""
        return _Math.HotspotListF_push_back(self, x)


    def front(self):
        """front(HotspotListF self) -> NamedCoordF"""
        return _Math.HotspotListF_front(self)


    def back(self):
        """back(HotspotListF self) -> NamedCoordF"""
        return _Math.HotspotListF_back(self)


    def assign(self, n, x):
        """assign(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type n, NamedCoordF x)"""
        return _Math.HotspotListF_assign(self, n, x)


    def resize(self, *args):
        """
        resize(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type new_size)
        resize(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type new_size, NamedCoordF x)
        """
        return _Math.HotspotListF_resize(self, *args)


    def insert(self, *args):
        """
        insert(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator pos, NamedCoordF x) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator
        insert(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::iterator pos, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type n, NamedCoordF x)
        """
        return _Math.HotspotListF_insert(self, *args)


    def reserve(self, n):
        """reserve(HotspotListF self, std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type n)"""
        return _Math.HotspotListF_reserve(self, n)


    def capacity(self):
        """capacity(HotspotListF self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< float > >::size_type"""
        return _Math.HotspotListF_capacity(self)

    __swig_destroy__ = _Math.delete_HotspotListF
    __del__ = lambda self: None
HotspotListF_swigregister = _Math.HotspotListF_swigregister
HotspotListF_swigregister(HotspotListF)

class HotspotListD(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::NamedCoordD)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HotspotListD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HotspotListD, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(HotspotListD self) -> SwigPyIterator"""
        return _Math.HotspotListD_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(HotspotListD self) -> bool"""
        return _Math.HotspotListD___nonzero__(self)


    def __bool__(self):
        """__bool__(HotspotListD self) -> bool"""
        return _Math.HotspotListD___bool__(self)


    def __len__(self):
        """__len__(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type"""
        return _Math.HotspotListD___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type j) -> HotspotListD"""
        return _Math.HotspotListD___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type j)
        __setslice__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type j, HotspotListD v)
        """
        return _Math.HotspotListD___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type j)"""
        return _Math.HotspotListD___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i)
        __delitem__(HotspotListD self, PySliceObject * slice)
        """
        return _Math.HotspotListD___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(HotspotListD self, PySliceObject * slice) -> HotspotListD
        __getitem__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i) -> NamedCoordD
        """
        return _Math.HotspotListD___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(HotspotListD self, PySliceObject * slice, HotspotListD v)
        __setitem__(HotspotListD self, PySliceObject * slice)
        __setitem__(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::difference_type i, NamedCoordD x)
        """
        return _Math.HotspotListD___setitem__(self, *args)


    def pop(self):
        """pop(HotspotListD self) -> NamedCoordD"""
        return _Math.HotspotListD_pop(self)


    def append(self, x):
        """append(HotspotListD self, NamedCoordD x)"""
        return _Math.HotspotListD_append(self, x)


    def empty(self):
        """empty(HotspotListD self) -> bool"""
        return _Math.HotspotListD_empty(self)


    def size(self):
        """size(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type"""
        return _Math.HotspotListD_size(self)


    def swap(self, v):
        """swap(HotspotListD self, HotspotListD v)"""
        return _Math.HotspotListD_swap(self, v)


    def begin(self):
        """begin(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator"""
        return _Math.HotspotListD_begin(self)


    def end(self):
        """end(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator"""
        return _Math.HotspotListD_end(self)


    def rbegin(self):
        """rbegin(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::reverse_iterator"""
        return _Math.HotspotListD_rbegin(self)


    def rend(self):
        """rend(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::reverse_iterator"""
        return _Math.HotspotListD_rend(self)


    def clear(self):
        """clear(HotspotListD self)"""
        return _Math.HotspotListD_clear(self)


    def get_allocator(self):
        """get_allocator(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::allocator_type"""
        return _Math.HotspotListD_get_allocator(self)


    def pop_back(self):
        """pop_back(HotspotListD self)"""
        return _Math.HotspotListD_pop_back(self)


    def erase(self, *args):
        """
        erase(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator pos) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator
        erase(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator first, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator last) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator
        """
        return _Math.HotspotListD_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordD)> self) -> HotspotListD
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordD)> self, HotspotListD arg2) -> HotspotListD
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordD)> self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type size) -> HotspotListD
        __init__(std::vector<(Seiscomp::Math::Geo::NamedCoordD)> self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type size, NamedCoordD value) -> HotspotListD
        """
        this = _Math.new_HotspotListD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(HotspotListD self, NamedCoordD x)"""
        return _Math.HotspotListD_push_back(self, x)


    def front(self):
        """front(HotspotListD self) -> NamedCoordD"""
        return _Math.HotspotListD_front(self)


    def back(self):
        """back(HotspotListD self) -> NamedCoordD"""
        return _Math.HotspotListD_back(self)


    def assign(self, n, x):
        """assign(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type n, NamedCoordD x)"""
        return _Math.HotspotListD_assign(self, n, x)


    def resize(self, *args):
        """
        resize(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type new_size)
        resize(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type new_size, NamedCoordD x)
        """
        return _Math.HotspotListD_resize(self, *args)


    def insert(self, *args):
        """
        insert(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator pos, NamedCoordD x) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator
        insert(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::iterator pos, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type n, NamedCoordD x)
        """
        return _Math.HotspotListD_insert(self, *args)


    def reserve(self, n):
        """reserve(HotspotListD self, std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type n)"""
        return _Math.HotspotListD_reserve(self, n)


    def capacity(self):
        """capacity(HotspotListD self) -> std::vector< Seiscomp::Math::Geo::NamedCoord< double > >::size_type"""
        return _Math.HotspotListD_capacity(self)

    __swig_destroy__ = _Math.delete_HotspotListD
    __del__ = lambda self: None
HotspotListD_swigregister = _Math.HotspotListD_swigregister
HotspotListD_swigregister(HotspotListD)

class CityF(NamedCoordF):
    """Proxy of C++ Seiscomp::Math::Geo::City<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [NamedCoordF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityF, name, value)
    __swig_getmethods__ = {}
    for _s in [NamedCoordF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CityF, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::City<(float)> self) -> CityF
        __init__(Seiscomp::Math::Geo::City<(float)> self, std::string const & name, float lat_, float lon_, size_t population) -> CityF
        __init__(Seiscomp::Math::Geo::City<(float)> self, std::string const & name, std::string const & countryID, float lat_, float lon_, size_t population) -> CityF
        """
        this = _Math.new_CityF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_CityF
    __del__ = lambda self: None

    def setPopulation(self, population):
        """setPopulation(CityF self, double population)"""
        return _Math.CityF_setPopulation(self, population)


    def population(self):
        """population(CityF self) -> double"""
        return _Math.CityF_population(self)


    def setCountryID(self, arg2):
        """setCountryID(CityF self, std::string const & arg2)"""
        return _Math.CityF_setCountryID(self, arg2)


    def countryID(self):
        """countryID(CityF self) -> std::string const &"""
        return _Math.CityF_countryID(self)


    def setCategory(self, arg2):
        """setCategory(CityF self, std::string & arg2)"""
        return _Math.CityF_setCategory(self, arg2)


    def category(self):
        """category(CityF self) -> std::string const &"""
        return _Math.CityF_category(self)


    def serialize(self, ar):
        """serialize(CityF self, GenericArchive ar)"""
        return _Math.CityF_serialize(self, ar)

CityF_swigregister = _Math.CityF_swigregister
CityF_swigregister(CityF)

class CityD(NamedCoordD):
    """Proxy of C++ Seiscomp::Math::Geo::City<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [NamedCoordD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityD, name, value)
    __swig_getmethods__ = {}
    for _s in [NamedCoordD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CityD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::City<(double)> self) -> CityD
        __init__(Seiscomp::Math::Geo::City<(double)> self, std::string const & name, double lat_, double lon_, size_t population) -> CityD
        __init__(Seiscomp::Math::Geo::City<(double)> self, std::string const & name, std::string const & countryID, double lat_, double lon_, size_t population) -> CityD
        """
        this = _Math.new_CityD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_CityD
    __del__ = lambda self: None

    def setPopulation(self, population):
        """setPopulation(CityD self, double population)"""
        return _Math.CityD_setPopulation(self, population)


    def population(self):
        """population(CityD self) -> double"""
        return _Math.CityD_population(self)


    def setCountryID(self, arg2):
        """setCountryID(CityD self, std::string const & arg2)"""
        return _Math.CityD_setCountryID(self, arg2)


    def countryID(self):
        """countryID(CityD self) -> std::string const &"""
        return _Math.CityD_countryID(self)


    def setCategory(self, arg2):
        """setCategory(CityD self, std::string & arg2)"""
        return _Math.CityD_setCategory(self, arg2)


    def category(self):
        """category(CityD self) -> std::string const &"""
        return _Math.CityD_category(self)


    def serialize(self, ar):
        """serialize(CityD self, GenericArchive ar)"""
        return _Math.CityD_serialize(self, ar)

CityD_swigregister = _Math.CityD_swigregister
CityD_swigregister(CityD)

class CityListF(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::CityF)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityListF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CityListF, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(CityListF self) -> SwigPyIterator"""
        return _Math.CityListF_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(CityListF self) -> bool"""
        return _Math.CityListF___nonzero__(self)


    def __bool__(self):
        """__bool__(CityListF self) -> bool"""
        return _Math.CityListF___bool__(self)


    def __len__(self):
        """__len__(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::size_type"""
        return _Math.CityListF___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type j) -> CityListF"""
        return _Math.CityListF___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type j)
        __setslice__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type j, CityListF v)
        """
        return _Math.CityListF___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type j)"""
        return _Math.CityListF___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i)
        __delitem__(CityListF self, PySliceObject * slice)
        """
        return _Math.CityListF___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(CityListF self, PySliceObject * slice) -> CityListF
        __getitem__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i) -> CityF
        """
        return _Math.CityListF___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(CityListF self, PySliceObject * slice, CityListF v)
        __setitem__(CityListF self, PySliceObject * slice)
        __setitem__(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::difference_type i, CityF x)
        """
        return _Math.CityListF___setitem__(self, *args)


    def pop(self):
        """pop(CityListF self) -> CityF"""
        return _Math.CityListF_pop(self)


    def append(self, x):
        """append(CityListF self, CityF x)"""
        return _Math.CityListF_append(self, x)


    def empty(self):
        """empty(CityListF self) -> bool"""
        return _Math.CityListF_empty(self)


    def size(self):
        """size(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::size_type"""
        return _Math.CityListF_size(self)


    def swap(self, v):
        """swap(CityListF self, CityListF v)"""
        return _Math.CityListF_swap(self, v)


    def begin(self):
        """begin(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::iterator"""
        return _Math.CityListF_begin(self)


    def end(self):
        """end(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::iterator"""
        return _Math.CityListF_end(self)


    def rbegin(self):
        """rbegin(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::reverse_iterator"""
        return _Math.CityListF_rbegin(self)


    def rend(self):
        """rend(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::reverse_iterator"""
        return _Math.CityListF_rend(self)


    def clear(self):
        """clear(CityListF self)"""
        return _Math.CityListF_clear(self)


    def get_allocator(self):
        """get_allocator(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::allocator_type"""
        return _Math.CityListF_get_allocator(self)


    def pop_back(self):
        """pop_back(CityListF self)"""
        return _Math.CityListF_pop_back(self)


    def erase(self, *args):
        """
        erase(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::iterator pos) -> std::vector< Seiscomp::Math::Geo::City< float > >::iterator
        erase(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::iterator first, std::vector< Seiscomp::Math::Geo::City< float > >::iterator last) -> std::vector< Seiscomp::Math::Geo::City< float > >::iterator
        """
        return _Math.CityListF_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(Seiscomp::Math::Geo::CityF)> self) -> CityListF
        __init__(std::vector<(Seiscomp::Math::Geo::CityF)> self, CityListF arg2) -> CityListF
        __init__(std::vector<(Seiscomp::Math::Geo::CityF)> self, std::vector< Seiscomp::Math::Geo::City< float > >::size_type size) -> CityListF
        __init__(std::vector<(Seiscomp::Math::Geo::CityF)> self, std::vector< Seiscomp::Math::Geo::City< float > >::size_type size, CityF value) -> CityListF
        """
        this = _Math.new_CityListF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(CityListF self, CityF x)"""
        return _Math.CityListF_push_back(self, x)


    def front(self):
        """front(CityListF self) -> CityF"""
        return _Math.CityListF_front(self)


    def back(self):
        """back(CityListF self) -> CityF"""
        return _Math.CityListF_back(self)


    def assign(self, n, x):
        """assign(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::size_type n, CityF x)"""
        return _Math.CityListF_assign(self, n, x)


    def resize(self, *args):
        """
        resize(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::size_type new_size)
        resize(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::size_type new_size, CityF x)
        """
        return _Math.CityListF_resize(self, *args)


    def insert(self, *args):
        """
        insert(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::iterator pos, CityF x) -> std::vector< Seiscomp::Math::Geo::City< float > >::iterator
        insert(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::iterator pos, std::vector< Seiscomp::Math::Geo::City< float > >::size_type n, CityF x)
        """
        return _Math.CityListF_insert(self, *args)


    def reserve(self, n):
        """reserve(CityListF self, std::vector< Seiscomp::Math::Geo::City< float > >::size_type n)"""
        return _Math.CityListF_reserve(self, n)


    def capacity(self):
        """capacity(CityListF self) -> std::vector< Seiscomp::Math::Geo::City< float > >::size_type"""
        return _Math.CityListF_capacity(self)

    __swig_destroy__ = _Math.delete_CityListF
    __del__ = lambda self: None
CityListF_swigregister = _Math.CityListF_swigregister
CityListF_swigregister(CityListF)

class CityListD(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::CityD)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityListD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CityListD, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(CityListD self) -> SwigPyIterator"""
        return _Math.CityListD_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(CityListD self) -> bool"""
        return _Math.CityListD___nonzero__(self)


    def __bool__(self):
        """__bool__(CityListD self) -> bool"""
        return _Math.CityListD___bool__(self)


    def __len__(self):
        """__len__(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::size_type"""
        return _Math.CityListD___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type j) -> CityListD"""
        return _Math.CityListD___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type j)
        __setslice__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type j, CityListD v)
        """
        return _Math.CityListD___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type j)"""
        return _Math.CityListD___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i)
        __delitem__(CityListD self, PySliceObject * slice)
        """
        return _Math.CityListD___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(CityListD self, PySliceObject * slice) -> CityListD
        __getitem__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i) -> CityD
        """
        return _Math.CityListD___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(CityListD self, PySliceObject * slice, CityListD v)
        __setitem__(CityListD self, PySliceObject * slice)
        __setitem__(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::difference_type i, CityD x)
        """
        return _Math.CityListD___setitem__(self, *args)


    def pop(self):
        """pop(CityListD self) -> CityD"""
        return _Math.CityListD_pop(self)


    def append(self, x):
        """append(CityListD self, CityD x)"""
        return _Math.CityListD_append(self, x)


    def empty(self):
        """empty(CityListD self) -> bool"""
        return _Math.CityListD_empty(self)


    def size(self):
        """size(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::size_type"""
        return _Math.CityListD_size(self)


    def swap(self, v):
        """swap(CityListD self, CityListD v)"""
        return _Math.CityListD_swap(self, v)


    def begin(self):
        """begin(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::iterator"""
        return _Math.CityListD_begin(self)


    def end(self):
        """end(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::iterator"""
        return _Math.CityListD_end(self)


    def rbegin(self):
        """rbegin(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::reverse_iterator"""
        return _Math.CityListD_rbegin(self)


    def rend(self):
        """rend(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::reverse_iterator"""
        return _Math.CityListD_rend(self)


    def clear(self):
        """clear(CityListD self)"""
        return _Math.CityListD_clear(self)


    def get_allocator(self):
        """get_allocator(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::allocator_type"""
        return _Math.CityListD_get_allocator(self)


    def pop_back(self):
        """pop_back(CityListD self)"""
        return _Math.CityListD_pop_back(self)


    def erase(self, *args):
        """
        erase(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::iterator pos) -> std::vector< Seiscomp::Math::Geo::City< double > >::iterator
        erase(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::iterator first, std::vector< Seiscomp::Math::Geo::City< double > >::iterator last) -> std::vector< Seiscomp::Math::Geo::City< double > >::iterator
        """
        return _Math.CityListD_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(Seiscomp::Math::Geo::CityD)> self) -> CityListD
        __init__(std::vector<(Seiscomp::Math::Geo::CityD)> self, CityListD arg2) -> CityListD
        __init__(std::vector<(Seiscomp::Math::Geo::CityD)> self, std::vector< Seiscomp::Math::Geo::City< double > >::size_type size) -> CityListD
        __init__(std::vector<(Seiscomp::Math::Geo::CityD)> self, std::vector< Seiscomp::Math::Geo::City< double > >::size_type size, CityD value) -> CityListD
        """
        this = _Math.new_CityListD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(CityListD self, CityD x)"""
        return _Math.CityListD_push_back(self, x)


    def front(self):
        """front(CityListD self) -> CityD"""
        return _Math.CityListD_front(self)


    def back(self):
        """back(CityListD self) -> CityD"""
        return _Math.CityListD_back(self)


    def assign(self, n, x):
        """assign(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::size_type n, CityD x)"""
        return _Math.CityListD_assign(self, n, x)


    def resize(self, *args):
        """
        resize(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::size_type new_size)
        resize(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::size_type new_size, CityD x)
        """
        return _Math.CityListD_resize(self, *args)


    def insert(self, *args):
        """
        insert(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::iterator pos, CityD x) -> std::vector< Seiscomp::Math::Geo::City< double > >::iterator
        insert(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::iterator pos, std::vector< Seiscomp::Math::Geo::City< double > >::size_type n, CityD x)
        """
        return _Math.CityListD_insert(self, *args)


    def reserve(self, n):
        """reserve(CityListD self, std::vector< Seiscomp::Math::Geo::City< double > >::size_type n)"""
        return _Math.CityListD_reserve(self, n)


    def capacity(self):
        """capacity(CityListD self) -> std::vector< Seiscomp::Math::Geo::City< double > >::size_type"""
        return _Math.CityListD_capacity(self)

    __swig_destroy__ = _Math.delete_CityListD
    __del__ = lambda self: None
CityListD_swigregister = _Math.CityListD_swigregister
CityListD_swigregister(CityListD)

class AlignmentError(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::AlignmentError class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AlignmentError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AlignmentError, name)
    __repr__ = _swig_repr

    def __init__(self, txt):
        """__init__(Seiscomp::Math::Filtering::AlignmentError self, char const * txt) -> AlignmentError"""
        this = _Math.new_AlignmentError(txt)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def what(self):
        """what(AlignmentError self) -> char const *"""
        return _Math.AlignmentError_what(self)

    __swig_destroy__ = _Math.delete_AlignmentError
    __del__ = lambda self: None
AlignmentError_swigregister = _Math.AlignmentError_swigregister
AlignmentError_swigregister(AlignmentError)


def next_power_of_2(arg1):
    """next_power_of_2(long arg1) -> long"""
    return _Math.next_power_of_2(arg1)
class InPlaceFilterF(seiscomp3.Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Filtering::InPlaceFilter<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InPlaceFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InPlaceFilterF, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Math.delete_InPlaceFilterF
    __del__ = lambda self: None

    def setStartTime(self, time):
        """setStartTime(InPlaceFilterF self, Time time)"""
        return _Math.InPlaceFilterF_setStartTime(self, time)


    def setStreamID(self, net, sta, loc, cha):
        """setStreamID(InPlaceFilterF self, std::string const & net, std::string const & sta, std::string const & loc, std::string const & cha)"""
        return _Math.InPlaceFilterF_setStreamID(self, net, sta, loc, cha)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(InPlaceFilterF self, double fsamp)"""
        return _Math.InPlaceFilterF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(InPlaceFilterF self, int n, double const * params) -> int"""
        return _Math.InPlaceFilterF_setParameters(self, n, params)


    def apply(self, *args):
        """
        apply(InPlaceFilterF self, int n, float * inout)
        apply(InPlaceFilterF self, vectorf f)
        apply(InPlaceFilterF self, FloatArrayT arr)
        """
        return _Math.InPlaceFilterF_apply(self, *args)


    def handleGap(self, n=0):
        """
        handleGap(InPlaceFilterF self, int n=0)
        handleGap(InPlaceFilterF self)
        """
        return _Math.InPlaceFilterF_handleGap(self, n)


    def clone(self):
        """clone(InPlaceFilterF self) -> InPlaceFilterF"""
        return _Math.InPlaceFilterF_clone(self)


    def Create(strFilter, strError=None):
        """
        Create(std::string const & strFilter, std::string * strError=None) -> InPlaceFilterF
        Create(std::string const & strFilter) -> InPlaceFilterF
        """
        return _Math.InPlaceFilterF_Create(strFilter, strError)

    Create = staticmethod(Create)
InPlaceFilterF_swigregister = _Math.InPlaceFilterF_swigregister
InPlaceFilterF_swigregister(InPlaceFilterF)

def InPlaceFilterF_Create(strFilter, strError=None):
    """
    Create(std::string const & strFilter, std::string * strError=None) -> InPlaceFilterF
    InPlaceFilterF_Create(std::string const & strFilter) -> InPlaceFilterF
    """
    return _Math.InPlaceFilterF_Create(strFilter, strError)

class InPlaceFilterD(seiscomp3.Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Filtering::InPlaceFilter<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InPlaceFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InPlaceFilterD, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Math.delete_InPlaceFilterD
    __del__ = lambda self: None

    def setStartTime(self, time):
        """setStartTime(InPlaceFilterD self, Time time)"""
        return _Math.InPlaceFilterD_setStartTime(self, time)


    def setStreamID(self, net, sta, loc, cha):
        """setStreamID(InPlaceFilterD self, std::string const & net, std::string const & sta, std::string const & loc, std::string const & cha)"""
        return _Math.InPlaceFilterD_setStreamID(self, net, sta, loc, cha)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(InPlaceFilterD self, double fsamp)"""
        return _Math.InPlaceFilterD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(InPlaceFilterD self, int n, double const * params) -> int"""
        return _Math.InPlaceFilterD_setParameters(self, n, params)


    def apply(self, *args):
        """
        apply(InPlaceFilterD self, int n, double * inout)
        apply(InPlaceFilterD self, vectord f)
        apply(InPlaceFilterD self, DoubleArrayT arr)
        """
        return _Math.InPlaceFilterD_apply(self, *args)


    def handleGap(self, n=0):
        """
        handleGap(InPlaceFilterD self, int n=0)
        handleGap(InPlaceFilterD self)
        """
        return _Math.InPlaceFilterD_handleGap(self, n)


    def clone(self):
        """clone(InPlaceFilterD self) -> InPlaceFilterD"""
        return _Math.InPlaceFilterD_clone(self)


    def Create(strFilter, strError=None):
        """
        Create(std::string const & strFilter, std::string * strError=None) -> InPlaceFilterD
        Create(std::string const & strFilter) -> InPlaceFilterD
        """
        return _Math.InPlaceFilterD_Create(strFilter, strError)

    Create = staticmethod(Create)
InPlaceFilterD_swigregister = _Math.InPlaceFilterD_swigregister
InPlaceFilterD_swigregister(InPlaceFilterD)

def InPlaceFilterD_Create(strFilter, strError=None):
    """
    Create(std::string const & strFilter, std::string * strError=None) -> InPlaceFilterD
    InPlaceFilterD_Create(std::string const & strFilter) -> InPlaceFilterD
    """
    return _Math.InPlaceFilterD_Create(strFilter, strError)

class AverageFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::Average<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AverageFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AverageFilterF, name)
    __repr__ = _swig_repr

    def __init__(self, timeSpan=1.0, fsamp=0.0):
        """
        __init__(Seiscomp::Math::Filtering::Average<(float)> self, double timeSpan=1.0, double fsamp=0.0) -> AverageFilterF
        __init__(Seiscomp::Math::Filtering::Average<(float)> self, double timeSpan=1.0) -> AverageFilterF
        __init__(Seiscomp::Math::Filtering::Average<(float)> self) -> AverageFilterF
        """
        this = _Math.new_AverageFilterF(timeSpan, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setLength(self, timeSpan):
        """setLength(AverageFilterF self, double timeSpan)"""
        return _Math.AverageFilterF_setLength(self, timeSpan)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(AverageFilterF self, double fsamp)"""
        return _Math.AverageFilterF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(AverageFilterF self, int n, double const * params) -> int"""
        return _Math.AverageFilterF_setParameters(self, n, params)


    def apply(self, n, inout):
        """apply(AverageFilterF self, int n, float * inout)"""
        return _Math.AverageFilterF_apply(self, n, inout)


    def clone(self):
        """clone(AverageFilterF self) -> InPlaceFilterF"""
        return _Math.AverageFilterF_clone(self)


    def reset(self):
        """reset(AverageFilterF self)"""
        return _Math.AverageFilterF_reset(self)

    __swig_destroy__ = _Math.delete_AverageFilterF
    __del__ = lambda self: None
AverageFilterF_swigregister = _Math.AverageFilterF_swigregister
AverageFilterF_swigregister(AverageFilterF)

class AverageFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::Average<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AverageFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AverageFilterD, name)
    __repr__ = _swig_repr

    def __init__(self, timeSpan=1.0, fsamp=0.0):
        """
        __init__(Seiscomp::Math::Filtering::Average<(double)> self, double timeSpan=1.0, double fsamp=0.0) -> AverageFilterD
        __init__(Seiscomp::Math::Filtering::Average<(double)> self, double timeSpan=1.0) -> AverageFilterD
        __init__(Seiscomp::Math::Filtering::Average<(double)> self) -> AverageFilterD
        """
        this = _Math.new_AverageFilterD(timeSpan, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setLength(self, timeSpan):
        """setLength(AverageFilterD self, double timeSpan)"""
        return _Math.AverageFilterD_setLength(self, timeSpan)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(AverageFilterD self, double fsamp)"""
        return _Math.AverageFilterD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(AverageFilterD self, int n, double const * params) -> int"""
        return _Math.AverageFilterD_setParameters(self, n, params)


    def apply(self, n, inout):
        """apply(AverageFilterD self, int n, double * inout)"""
        return _Math.AverageFilterD_apply(self, n, inout)


    def clone(self):
        """clone(AverageFilterD self) -> InPlaceFilterD"""
        return _Math.AverageFilterD_clone(self)


    def reset(self):
        """reset(AverageFilterD self)"""
        return _Math.AverageFilterD_reset(self)

    __swig_destroy__ = _Math.delete_AverageFilterD
    __del__ = lambda self: None
AverageFilterD_swigregister = _Math.AverageFilterD_swigregister
AverageFilterD_swigregister(AverageFilterD)

class STALTAFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::STALTA<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STALTAFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, STALTAFilterF, name)
    __repr__ = _swig_repr

    def __init__(self, lenSTA=2, lenLTA=50, fsamp=1.):
        """
        __init__(Seiscomp::Math::Filtering::STALTA<(float)> self, double lenSTA=2, double lenLTA=50, double fsamp=1.) -> STALTAFilterF
        __init__(Seiscomp::Math::Filtering::STALTA<(float)> self, double lenSTA=2, double lenLTA=50) -> STALTAFilterF
        __init__(Seiscomp::Math::Filtering::STALTA<(float)> self, double lenSTA=2) -> STALTAFilterF
        __init__(Seiscomp::Math::Filtering::STALTA<(float)> self) -> STALTAFilterF
        """
        this = _Math.new_STALTAFilterF(lenSTA, lenLTA, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSaveIntermediate(self, arg2):
        """setSaveIntermediate(STALTAFilterF self, bool arg2)"""
        return _Math.STALTAFilterF_setSaveIntermediate(self, arg2)


    def apply(self, ndata, data):
        """apply(STALTAFilterF self, int ndata, float * data)"""
        return _Math.STALTAFilterF_apply(self, ndata, data)


    def reset(self):
        """reset(STALTAFilterF self)"""
        return _Math.STALTAFilterF_reset(self)


    def changed(self):
        """changed(STALTAFilterF self) -> bool"""
        return _Math.STALTAFilterF_changed(self)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(STALTAFilterF self, double fsamp)"""
        return _Math.STALTAFilterF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(STALTAFilterF self, int n, double const * params) -> int"""
        return _Math.STALTAFilterF_setParameters(self, n, params)


    def clone(self):
        """clone(STALTAFilterF self) -> InPlaceFilterF"""
        return _Math.STALTAFilterF_clone(self)


    def getSTA(self):
        """getSTA(STALTAFilterF self) -> vectorf"""
        return _Math.STALTAFilterF_getSTA(self)


    def getLTA(self):
        """getLTA(STALTAFilterF self) -> vectorf"""
        return _Math.STALTAFilterF_getLTA(self)

    __swig_destroy__ = _Math.delete_STALTAFilterF
    __del__ = lambda self: None
STALTAFilterF_swigregister = _Math.STALTAFilterF_swigregister
STALTAFilterF_swigregister(STALTAFilterF)

class STALTAFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::STALTA<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STALTAFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, STALTAFilterD, name)
    __repr__ = _swig_repr

    def __init__(self, lenSTA=2, lenLTA=50, fsamp=1.):
        """
        __init__(Seiscomp::Math::Filtering::STALTA<(double)> self, double lenSTA=2, double lenLTA=50, double fsamp=1.) -> STALTAFilterD
        __init__(Seiscomp::Math::Filtering::STALTA<(double)> self, double lenSTA=2, double lenLTA=50) -> STALTAFilterD
        __init__(Seiscomp::Math::Filtering::STALTA<(double)> self, double lenSTA=2) -> STALTAFilterD
        __init__(Seiscomp::Math::Filtering::STALTA<(double)> self) -> STALTAFilterD
        """
        this = _Math.new_STALTAFilterD(lenSTA, lenLTA, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSaveIntermediate(self, arg2):
        """setSaveIntermediate(STALTAFilterD self, bool arg2)"""
        return _Math.STALTAFilterD_setSaveIntermediate(self, arg2)


    def apply(self, ndata, data):
        """apply(STALTAFilterD self, int ndata, double * data)"""
        return _Math.STALTAFilterD_apply(self, ndata, data)


    def reset(self):
        """reset(STALTAFilterD self)"""
        return _Math.STALTAFilterD_reset(self)


    def changed(self):
        """changed(STALTAFilterD self) -> bool"""
        return _Math.STALTAFilterD_changed(self)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(STALTAFilterD self, double fsamp)"""
        return _Math.STALTAFilterD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(STALTAFilterD self, int n, double const * params) -> int"""
        return _Math.STALTAFilterD_setParameters(self, n, params)


    def clone(self):
        """clone(STALTAFilterD self) -> InPlaceFilterD"""
        return _Math.STALTAFilterD_clone(self)


    def getSTA(self):
        """getSTA(STALTAFilterD self) -> vectord"""
        return _Math.STALTAFilterD_getSTA(self)


    def getLTA(self):
        """getLTA(STALTAFilterD self) -> vectord"""
        return _Math.STALTAFilterD_getLTA(self)

    __swig_destroy__ = _Math.delete_STALTAFilterD
    __del__ = lambda self: None
STALTAFilterD_swigregister = _Math.STALTAFilterD_swigregister
STALTAFilterD_swigregister(STALTAFilterD)

class RunningMeanFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::RunningMean<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunningMeanFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RunningMeanFilterF, name)
    __repr__ = _swig_repr

    def __init__(self, windowLength=0, fsamp=0.0):
        """
        __init__(Seiscomp::Math::Filtering::RunningMean<(float)> self, double windowLength=0, double fsamp=0.0) -> RunningMeanFilterF
        __init__(Seiscomp::Math::Filtering::RunningMean<(float)> self, double windowLength=0) -> RunningMeanFilterF
        __init__(Seiscomp::Math::Filtering::RunningMean<(float)> self) -> RunningMeanFilterF
        """
        this = _Math.new_RunningMeanFilterF(windowLength, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_RunningMeanFilterF
    __del__ = lambda self: None

    def setLength(self, windowLength):
        """setLength(RunningMeanFilterF self, double windowLength)"""
        return _Math.RunningMeanFilterF_setLength(self, windowLength)


    def apply(self, n, inout):
        """apply(RunningMeanFilterF self, int n, float * inout)"""
        return _Math.RunningMeanFilterF_apply(self, n, inout)


    def clone(self):
        """clone(RunningMeanFilterF self) -> InPlaceFilterF"""
        return _Math.RunningMeanFilterF_clone(self)


    def reset(self):
        """reset(RunningMeanFilterF self)"""
        return _Math.RunningMeanFilterF_reset(self)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(RunningMeanFilterF self, double fsamp)"""
        return _Math.RunningMeanFilterF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(RunningMeanFilterF self, int n, double const * params) -> int"""
        return _Math.RunningMeanFilterF_setParameters(self, n, params)

RunningMeanFilterF_swigregister = _Math.RunningMeanFilterF_swigregister
RunningMeanFilterF_swigregister(RunningMeanFilterF)

class RunningMeanFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::RunningMean<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunningMeanFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RunningMeanFilterD, name)
    __repr__ = _swig_repr

    def __init__(self, windowLength=0, fsamp=0.0):
        """
        __init__(Seiscomp::Math::Filtering::RunningMean<(double)> self, double windowLength=0, double fsamp=0.0) -> RunningMeanFilterD
        __init__(Seiscomp::Math::Filtering::RunningMean<(double)> self, double windowLength=0) -> RunningMeanFilterD
        __init__(Seiscomp::Math::Filtering::RunningMean<(double)> self) -> RunningMeanFilterD
        """
        this = _Math.new_RunningMeanFilterD(windowLength, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_RunningMeanFilterD
    __del__ = lambda self: None

    def setLength(self, windowLength):
        """setLength(RunningMeanFilterD self, double windowLength)"""
        return _Math.RunningMeanFilterD_setLength(self, windowLength)


    def apply(self, n, inout):
        """apply(RunningMeanFilterD self, int n, double * inout)"""
        return _Math.RunningMeanFilterD_apply(self, n, inout)


    def clone(self):
        """clone(RunningMeanFilterD self) -> InPlaceFilterD"""
        return _Math.RunningMeanFilterD_clone(self)


    def reset(self):
        """reset(RunningMeanFilterD self)"""
        return _Math.RunningMeanFilterD_reset(self)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(RunningMeanFilterD self, double fsamp)"""
        return _Math.RunningMeanFilterD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(RunningMeanFilterD self, int n, double const * params) -> int"""
        return _Math.RunningMeanFilterD_setParameters(self, n, params)

RunningMeanFilterD_swigregister = _Math.RunningMeanFilterD_swigregister
RunningMeanFilterD_swigregister(RunningMeanFilterD)

class RunningMeanHighPassFilterF(RunningMeanFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::RunningMeanHighPass<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [RunningMeanFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunningMeanHighPassFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [RunningMeanFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RunningMeanHighPassFilterF, name)
    __repr__ = _swig_repr

    def __init__(self, windowLength=0, fsamp=0.0):
        """
        __init__(Seiscomp::Math::Filtering::RunningMeanHighPass<(float)> self, double windowLength=0, double fsamp=0.0) -> RunningMeanHighPassFilterF
        __init__(Seiscomp::Math::Filtering::RunningMeanHighPass<(float)> self, double windowLength=0) -> RunningMeanHighPassFilterF
        __init__(Seiscomp::Math::Filtering::RunningMeanHighPass<(float)> self) -> RunningMeanHighPassFilterF
        """
        this = _Math.new_RunningMeanHighPassFilterF(windowLength, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_RunningMeanHighPassFilterF
    __del__ = lambda self: None

    def apply(self, n, inout):
        """apply(RunningMeanHighPassFilterF self, int n, float * inout)"""
        return _Math.RunningMeanHighPassFilterF_apply(self, n, inout)


    def clone(self):
        """clone(RunningMeanHighPassFilterF self) -> InPlaceFilterF"""
        return _Math.RunningMeanHighPassFilterF_clone(self)

RunningMeanHighPassFilterF_swigregister = _Math.RunningMeanHighPassFilterF_swigregister
RunningMeanHighPassFilterF_swigregister(RunningMeanHighPassFilterF)

class RunningMeanHighPassFilterD(RunningMeanFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::RunningMeanHighPass<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [RunningMeanFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunningMeanHighPassFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [RunningMeanFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RunningMeanHighPassFilterD, name)
    __repr__ = _swig_repr

    def __init__(self, windowLength=0, fsamp=0.0):
        """
        __init__(Seiscomp::Math::Filtering::RunningMeanHighPass<(double)> self, double windowLength=0, double fsamp=0.0) -> RunningMeanHighPassFilterD
        __init__(Seiscomp::Math::Filtering::RunningMeanHighPass<(double)> self, double windowLength=0) -> RunningMeanHighPassFilterD
        __init__(Seiscomp::Math::Filtering::RunningMeanHighPass<(double)> self) -> RunningMeanHighPassFilterD
        """
        this = _Math.new_RunningMeanHighPassFilterD(windowLength, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_RunningMeanHighPassFilterD
    __del__ = lambda self: None

    def apply(self, n, inout):
        """apply(RunningMeanHighPassFilterD self, int n, double * inout)"""
        return _Math.RunningMeanHighPassFilterD_apply(self, n, inout)


    def clone(self):
        """clone(RunningMeanHighPassFilterD self) -> InPlaceFilterD"""
        return _Math.RunningMeanHighPassFilterD_clone(self)

RunningMeanHighPassFilterD_swigregister = _Math.RunningMeanHighPassFilterD_swigregister
RunningMeanHighPassFilterD_swigregister(RunningMeanHighPassFilterD)

class InitialTaperFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::InitialTaper<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitialTaperFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitialTaperFilterF, name)
    __repr__ = _swig_repr

    def __init__(self, taperLength=0, offset=0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::InitialTaper<(float)> self, double taperLength=0, float offset=0, double fsamp=0) -> InitialTaperFilterF
        __init__(Seiscomp::Math::Filtering::InitialTaper<(float)> self, double taperLength=0, float offset=0) -> InitialTaperFilterF
        __init__(Seiscomp::Math::Filtering::InitialTaper<(float)> self, double taperLength=0) -> InitialTaperFilterF
        __init__(Seiscomp::Math::Filtering::InitialTaper<(float)> self) -> InitialTaperFilterF
        """
        this = _Math.new_InitialTaperFilterF(taperLength, offset, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_InitialTaperFilterF
    __del__ = lambda self: None

    def setLength(self, taperLength, offset=0):
        """
        setLength(InitialTaperFilterF self, double taperLength, float offset=0)
        setLength(InitialTaperFilterF self, double taperLength)
        """
        return _Math.InitialTaperFilterF_setLength(self, taperLength, offset)


    def apply(self, n, inout):
        """apply(InitialTaperFilterF self, int n, float * inout)"""
        return _Math.InitialTaperFilterF_apply(self, n, inout)


    def clone(self):
        """clone(InitialTaperFilterF self) -> InPlaceFilterF"""
        return _Math.InitialTaperFilterF_clone(self)


    def reset(self):
        """reset(InitialTaperFilterF self)"""
        return _Math.InitialTaperFilterF_reset(self)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(InitialTaperFilterF self, double fsamp)"""
        return _Math.InitialTaperFilterF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(InitialTaperFilterF self, int n, double const * params) -> int"""
        return _Math.InitialTaperFilterF_setParameters(self, n, params)

InitialTaperFilterF_swigregister = _Math.InitialTaperFilterF_swigregister
InitialTaperFilterF_swigregister(InitialTaperFilterF)

class InitialTaperFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::InitialTaper<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitialTaperFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitialTaperFilterD, name)
    __repr__ = _swig_repr

    def __init__(self, taperLength=0, offset=0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::InitialTaper<(double)> self, double taperLength=0, double offset=0, double fsamp=0) -> InitialTaperFilterD
        __init__(Seiscomp::Math::Filtering::InitialTaper<(double)> self, double taperLength=0, double offset=0) -> InitialTaperFilterD
        __init__(Seiscomp::Math::Filtering::InitialTaper<(double)> self, double taperLength=0) -> InitialTaperFilterD
        __init__(Seiscomp::Math::Filtering::InitialTaper<(double)> self) -> InitialTaperFilterD
        """
        this = _Math.new_InitialTaperFilterD(taperLength, offset, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_InitialTaperFilterD
    __del__ = lambda self: None

    def setLength(self, taperLength, offset=0):
        """
        setLength(InitialTaperFilterD self, double taperLength, double offset=0)
        setLength(InitialTaperFilterD self, double taperLength)
        """
        return _Math.InitialTaperFilterD_setLength(self, taperLength, offset)


    def apply(self, n, inout):
        """apply(InitialTaperFilterD self, int n, double * inout)"""
        return _Math.InitialTaperFilterD_apply(self, n, inout)


    def clone(self):
        """clone(InitialTaperFilterD self) -> InPlaceFilterD"""
        return _Math.InitialTaperFilterD_clone(self)


    def reset(self):
        """reset(InitialTaperFilterD self)"""
        return _Math.InitialTaperFilterD_reset(self)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(InitialTaperFilterD self, double fsamp)"""
        return _Math.InitialTaperFilterD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(InitialTaperFilterD self, int n, double const * params) -> int"""
        return _Math.InitialTaperFilterD_setParameters(self, n, params)

InitialTaperFilterD_swigregister = _Math.InitialTaperFilterD_swigregister
InitialTaperFilterD_swigregister(InitialTaperFilterD)

class BiquadCoefficients(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::BiquadCoefficients class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BiquadCoefficients, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BiquadCoefficients, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, double b0=0, double b1=0, double b2=0, double a0=1, double a1=0, double a2=0) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, double b0=0, double b1=0, double b2=0, double a0=1, double a1=0) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, double b0=0, double b1=0, double b2=0, double a0=1) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, double b0=0, double b1=0, double b2=0) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, double b0=0, double b1=0) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, double b0=0) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self) -> BiquadCoefficients
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCoefficients self, BiquadCoefficients bq) -> BiquadCoefficients
        """
        this = _Math.new_BiquadCoefficients(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, b0, b1, b2, a0, a1, a2):
        """set(BiquadCoefficients self, double b0, double b1, double b2, double a0, double a1, double a2)"""
        return _Math.BiquadCoefficients_set(self, b0, b1, b2, a0, a1, a2)

    __swig_setmethods__["b0"] = _Math.BiquadCoefficients_b0_set
    __swig_getmethods__["b0"] = _Math.BiquadCoefficients_b0_get
    if _newclass:
        b0 = _swig_property(_Math.BiquadCoefficients_b0_get, _Math.BiquadCoefficients_b0_set)
    __swig_setmethods__["b1"] = _Math.BiquadCoefficients_b1_set
    __swig_getmethods__["b1"] = _Math.BiquadCoefficients_b1_get
    if _newclass:
        b1 = _swig_property(_Math.BiquadCoefficients_b1_get, _Math.BiquadCoefficients_b1_set)
    __swig_setmethods__["b2"] = _Math.BiquadCoefficients_b2_set
    __swig_getmethods__["b2"] = _Math.BiquadCoefficients_b2_get
    if _newclass:
        b2 = _swig_property(_Math.BiquadCoefficients_b2_get, _Math.BiquadCoefficients_b2_set)
    __swig_setmethods__["a0"] = _Math.BiquadCoefficients_a0_set
    __swig_getmethods__["a0"] = _Math.BiquadCoefficients_a0_get
    if _newclass:
        a0 = _swig_property(_Math.BiquadCoefficients_a0_get, _Math.BiquadCoefficients_a0_set)
    __swig_setmethods__["a1"] = _Math.BiquadCoefficients_a1_set
    __swig_getmethods__["a1"] = _Math.BiquadCoefficients_a1_get
    if _newclass:
        a1 = _swig_property(_Math.BiquadCoefficients_a1_get, _Math.BiquadCoefficients_a1_set)
    __swig_setmethods__["a2"] = _Math.BiquadCoefficients_a2_set
    __swig_getmethods__["a2"] = _Math.BiquadCoefficients_a2_get
    if _newclass:
        a2 = _swig_property(_Math.BiquadCoefficients_a2_get, _Math.BiquadCoefficients_a2_set)
    __swig_destroy__ = _Math.delete_BiquadCoefficients
    __del__ = lambda self: None
BiquadCoefficients_swigregister = _Math.BiquadCoefficients_swigregister
BiquadCoefficients_swigregister(BiquadCoefficients)


def __lshift__(os, biq):
    """__lshift__(std::ostream & os, BiquadCoefficients biq) -> std::ostream &"""
    return _Math.__lshift__(os, biq)
class BiquadCascadeF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::BiquadCascade<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BiquadCascadeF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BiquadCascadeF, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCascade<(float)> self) -> BiquadCascadeF
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCascade<(float)> self, BiquadCascadeF other) -> BiquadCascadeF
        """
        this = _Math.new_BiquadCascadeF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        """size(BiquadCascadeF self) -> int"""
        return _Math.BiquadCascadeF_size(self)


    def reset(self):
        """reset(BiquadCascadeF self)"""
        return _Math.BiquadCascadeF_reset(self)


    def append(self, biq):
        """append(BiquadCascadeF self, Seiscomp::Math::Filtering::IIR::Biquad< float > const & biq)"""
        return _Math.BiquadCascadeF_append(self, biq)


    def set(self, biquads):
        """set(BiquadCascadeF self, Seiscomp::Math::Filtering::IIR::Biquads const & biquads)"""
        return _Math.BiquadCascadeF_set(self, biquads)


    def apply(self, n, inout):
        """apply(BiquadCascadeF self, int n, float * inout)"""
        return _Math.BiquadCascadeF_apply(self, n, inout)


    def clone(self):
        """clone(BiquadCascadeF self) -> InPlaceFilterF"""
        return _Math.BiquadCascadeF_clone(self)


    def setSamplingFrequency(self, arg2):
        """setSamplingFrequency(BiquadCascadeF self, double arg2)"""
        return _Math.BiquadCascadeF_setSamplingFrequency(self, arg2)


    def setParameters(self, n, params):
        """setParameters(BiquadCascadeF self, int n, double const * params) -> int"""
        return _Math.BiquadCascadeF_setParameters(self, n, params)

    __swig_destroy__ = _Math.delete_BiquadCascadeF
    __del__ = lambda self: None
BiquadCascadeF_swigregister = _Math.BiquadCascadeF_swigregister
BiquadCascadeF_swigregister(BiquadCascadeF)

class BiquadCascadeD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::BiquadCascade<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BiquadCascadeD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BiquadCascadeD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCascade<(double)> self) -> BiquadCascadeD
        __init__(Seiscomp::Math::Filtering::IIR::BiquadCascade<(double)> self, BiquadCascadeD other) -> BiquadCascadeD
        """
        this = _Math.new_BiquadCascadeD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        """size(BiquadCascadeD self) -> int"""
        return _Math.BiquadCascadeD_size(self)


    def reset(self):
        """reset(BiquadCascadeD self)"""
        return _Math.BiquadCascadeD_reset(self)


    def append(self, biq):
        """append(BiquadCascadeD self, Seiscomp::Math::Filtering::IIR::Biquad< double > const & biq)"""
        return _Math.BiquadCascadeD_append(self, biq)


    def set(self, biquads):
        """set(BiquadCascadeD self, Seiscomp::Math::Filtering::IIR::Biquads const & biquads)"""
        return _Math.BiquadCascadeD_set(self, biquads)


    def apply(self, n, inout):
        """apply(BiquadCascadeD self, int n, double * inout)"""
        return _Math.BiquadCascadeD_apply(self, n, inout)


    def clone(self):
        """clone(BiquadCascadeD self) -> InPlaceFilterD"""
        return _Math.BiquadCascadeD_clone(self)


    def setSamplingFrequency(self, arg2):
        """setSamplingFrequency(BiquadCascadeD self, double arg2)"""
        return _Math.BiquadCascadeD_setSamplingFrequency(self, arg2)


    def setParameters(self, n, params):
        """setParameters(BiquadCascadeD self, int n, double const * params) -> int"""
        return _Math.BiquadCascadeD_setParameters(self, n, params)

    __swig_destroy__ = _Math.delete_BiquadCascadeD
    __del__ = lambda self: None
BiquadCascadeD_swigregister = _Math.BiquadCascadeD_swigregister
BiquadCascadeD_swigregister(BiquadCascadeD)

class ButterworthLowpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthLowpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthLowpassF, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmax=0.7, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(float)> self, int order=3, double fmax=0.7, double fsamp=0) -> ButterworthLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(float)> self, int order=3, double fmax=0.7) -> ButterworthLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(float)> self, int order=3) -> ButterworthLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(float)> self) -> ButterworthLowpassF
        """
        this = _Math.new_ButterworthLowpassF(order, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthLowpassF self, double fsamp)"""
        return _Math.ButterworthLowpassF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthLowpassF self, int n, double const * params) -> int"""
        return _Math.ButterworthLowpassF_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthLowpassF self) -> InPlaceFilterF"""
        return _Math.ButterworthLowpassF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthLowpassF
    __del__ = lambda self: None
ButterworthLowpassF_swigregister = _Math.ButterworthLowpassF_swigregister
ButterworthLowpassF_swigregister(ButterworthLowpassF)

class ButterworthLowpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthLowpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthLowpassD, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmax=0.7, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(double)> self, int order=3, double fmax=0.7, double fsamp=0) -> ButterworthLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(double)> self, int order=3, double fmax=0.7) -> ButterworthLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(double)> self, int order=3) -> ButterworthLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(double)> self) -> ButterworthLowpassD
        """
        this = _Math.new_ButterworthLowpassD(order, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthLowpassD self, double fsamp)"""
        return _Math.ButterworthLowpassD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthLowpassD self, int n, double const * params) -> int"""
        return _Math.ButterworthLowpassD_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthLowpassD self) -> InPlaceFilterD"""
        return _Math.ButterworthLowpassD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthLowpassD
    __del__ = lambda self: None
ButterworthLowpassD_swigregister = _Math.ButterworthLowpassD_swigregister
ButterworthLowpassD_swigregister(ButterworthLowpassD)

class ButterworthHighpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthHighpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthHighpassF, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(float)> self, int order=3, double fmin=2.0, double fsamp=0) -> ButterworthHighpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(float)> self, int order=3, double fmin=2.0) -> ButterworthHighpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(float)> self, int order=3) -> ButterworthHighpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(float)> self) -> ButterworthHighpassF
        """
        this = _Math.new_ButterworthHighpassF(order, fmin, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthHighpassF self, double fsamp)"""
        return _Math.ButterworthHighpassF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthHighpassF self, int n, double const * params) -> int"""
        return _Math.ButterworthHighpassF_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthHighpassF self) -> InPlaceFilterF"""
        return _Math.ButterworthHighpassF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthHighpassF
    __del__ = lambda self: None
ButterworthHighpassF_swigregister = _Math.ButterworthHighpassF_swigregister
ButterworthHighpassF_swigregister(ButterworthHighpassF)

class ButterworthHighpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthHighpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthHighpassD, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(double)> self, int order=3, double fmin=2.0, double fsamp=0) -> ButterworthHighpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(double)> self, int order=3, double fmin=2.0) -> ButterworthHighpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(double)> self, int order=3) -> ButterworthHighpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(double)> self) -> ButterworthHighpassD
        """
        this = _Math.new_ButterworthHighpassD(order, fmin, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthHighpassD self, double fsamp)"""
        return _Math.ButterworthHighpassD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthHighpassD self, int n, double const * params) -> int"""
        return _Math.ButterworthHighpassD_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthHighpassD self) -> InPlaceFilterD"""
        return _Math.ButterworthHighpassD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthHighpassD
    __del__ = lambda self: None
ButterworthHighpassD_swigregister = _Math.ButterworthHighpassD_swigregister
ButterworthHighpassD_swigregister(ButterworthHighpassD)

class ButterworthBandpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthBandpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthBandpassF, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=0.7, fmax=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> self, int order=3, double fmin=0.7, double fmax=2.0, double fsamp=0) -> ButterworthBandpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> self, int order=3, double fmin=0.7, double fmax=2.0) -> ButterworthBandpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> self, int order=3, double fmin=0.7) -> ButterworthBandpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> self, int order=3) -> ButterworthBandpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> self) -> ButterworthBandpassF
        """
        this = _Math.new_ButterworthBandpassF(order, fmin, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthBandpassF self, double fsamp)"""
        return _Math.ButterworthBandpassF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthBandpassF self, int n, double const * params) -> int"""
        return _Math.ButterworthBandpassF_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthBandpassF self) -> InPlaceFilterF"""
        return _Math.ButterworthBandpassF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthBandpassF
    __del__ = lambda self: None
ButterworthBandpassF_swigregister = _Math.ButterworthBandpassF_swigregister
ButterworthBandpassF_swigregister(ButterworthBandpassF)

class ButterworthBandpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthBandpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthBandpassD, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=0.7, fmax=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> self, int order=3, double fmin=0.7, double fmax=2.0, double fsamp=0) -> ButterworthBandpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> self, int order=3, double fmin=0.7, double fmax=2.0) -> ButterworthBandpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> self, int order=3, double fmin=0.7) -> ButterworthBandpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> self, int order=3) -> ButterworthBandpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> self) -> ButterworthBandpassD
        """
        this = _Math.new_ButterworthBandpassD(order, fmin, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthBandpassD self, double fsamp)"""
        return _Math.ButterworthBandpassD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthBandpassD self, int n, double const * params) -> int"""
        return _Math.ButterworthBandpassD_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthBandpassD self) -> InPlaceFilterD"""
        return _Math.ButterworthBandpassD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthBandpassD
    __del__ = lambda self: None
ButterworthBandpassD_swigregister = _Math.ButterworthBandpassD_swigregister
ButterworthBandpassD_swigregister(ButterworthBandpassD)

class ButterworthHighLowpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthHighLowpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthHighLowpassF, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=0.7, fmax=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(float)> self, int order=3, double fmin=0.7, double fmax=2.0, double fsamp=0) -> ButterworthHighLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(float)> self, int order=3, double fmin=0.7, double fmax=2.0) -> ButterworthHighLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(float)> self, int order=3, double fmin=0.7) -> ButterworthHighLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(float)> self, int order=3) -> ButterworthHighLowpassF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(float)> self) -> ButterworthHighLowpassF
        """
        this = _Math.new_ButterworthHighLowpassF(order, fmin, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthHighLowpassF self, double fsamp)"""
        return _Math.ButterworthHighLowpassF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthHighLowpassF self, int n, double const * params) -> int"""
        return _Math.ButterworthHighLowpassF_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthHighLowpassF self) -> InPlaceFilterF"""
        return _Math.ButterworthHighLowpassF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthHighLowpassF
    __del__ = lambda self: None
ButterworthHighLowpassF_swigregister = _Math.ButterworthHighLowpassF_swigregister
ButterworthHighLowpassF_swigregister(ButterworthHighLowpassF)

class ButterworthHighLowpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthHighLowpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthHighLowpassD, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=0.7, fmax=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(double)> self, int order=3, double fmin=0.7, double fmax=2.0, double fsamp=0) -> ButterworthHighLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(double)> self, int order=3, double fmin=0.7, double fmax=2.0) -> ButterworthHighLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(double)> self, int order=3, double fmin=0.7) -> ButterworthHighLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(double)> self, int order=3) -> ButterworthHighLowpassD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthHighLowpass<(double)> self) -> ButterworthHighLowpassD
        """
        this = _Math.new_ButterworthHighLowpassD(order, fmin, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthHighLowpassD self, double fsamp)"""
        return _Math.ButterworthHighLowpassD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthHighLowpassD self, int n, double const * params) -> int"""
        return _Math.ButterworthHighLowpassD_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthHighLowpassD self) -> InPlaceFilterD"""
        return _Math.ButterworthHighLowpassD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthHighLowpassD
    __del__ = lambda self: None
ButterworthHighLowpassD_swigregister = _Math.ButterworthHighLowpassD_swigregister
ButterworthHighLowpassD_swigregister(ButterworthHighLowpassD)

class ButterworthBandstopF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthBandstopF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthBandstopF, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=0.7, fmax=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(float)> self, int order=3, double fmin=0.7, double fmax=2.0, double fsamp=0) -> ButterworthBandstopF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(float)> self, int order=3, double fmin=0.7, double fmax=2.0) -> ButterworthBandstopF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(float)> self, int order=3, double fmin=0.7) -> ButterworthBandstopF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(float)> self, int order=3) -> ButterworthBandstopF
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(float)> self) -> ButterworthBandstopF
        """
        this = _Math.new_ButterworthBandstopF(order, fmin, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthBandstopF self, double fsamp)"""
        return _Math.ButterworthBandstopF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthBandstopF self, int n, double const * params) -> int"""
        return _Math.ButterworthBandstopF_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthBandstopF self) -> InPlaceFilterF"""
        return _Math.ButterworthBandstopF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthBandstopF
    __del__ = lambda self: None
ButterworthBandstopF_swigregister = _Math.ButterworthBandstopF_swigregister
ButterworthBandstopF_swigregister(ButterworthBandstopF)

class ButterworthBandstopD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthBandstopD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthBandstopD, name)
    __repr__ = _swig_repr

    def __init__(self, order=3, fmin=0.7, fmax=2.0, fsamp=0):
        """
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(double)> self, int order=3, double fmin=0.7, double fmax=2.0, double fsamp=0) -> ButterworthBandstopD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(double)> self, int order=3, double fmin=0.7, double fmax=2.0) -> ButterworthBandstopD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(double)> self, int order=3, double fmin=0.7) -> ButterworthBandstopD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(double)> self, int order=3) -> ButterworthBandstopD
        __init__(Seiscomp::Math::Filtering::IIR::ButterworthBandstop<(double)> self) -> ButterworthBandstopD
        """
        this = _Math.new_ButterworthBandstopD(order, fmin, fmax, fsamp)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ButterworthBandstopD self, double fsamp)"""
        return _Math.ButterworthBandstopD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ButterworthBandstopD self, int n, double const * params) -> int"""
        return _Math.ButterworthBandstopD_setParameters(self, n, params)


    def clone(self):
        """clone(ButterworthBandstopD self) -> InPlaceFilterD"""
        return _Math.ButterworthBandstopD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthBandstopD
    __del__ = lambda self: None
ButterworthBandstopD_swigregister = _Math.ButterworthBandstopD_swigregister
ButterworthBandstopD_swigregister(ButterworthBandstopD)

class ChainFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::ChainFilter<(float)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChainFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChainFilterF, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Seiscomp::Math::Filtering::ChainFilter<(float)> self) -> ChainFilterF"""
        this = _Math.new_ChainFilterF()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_ChainFilterF
    __del__ = lambda self: None

    def add(self, filter):
        """add(ChainFilterF self, InPlaceFilterF filter) -> bool"""
        return _Math.ChainFilterF_add(self, filter)


    def remove(self, pos):
        """remove(ChainFilterF self, size_t pos) -> bool"""
        return _Math.ChainFilterF_remove(self, pos)


    def take(self, pos):
        """take(ChainFilterF self, size_t pos) -> InPlaceFilterF"""
        return _Math.ChainFilterF_take(self, pos)


    def indexOf(self, filter):
        """indexOf(ChainFilterF self, InPlaceFilterF filter) -> size_t"""
        return _Math.ChainFilterF_indexOf(self, filter)


    def filterCount(self):
        """filterCount(ChainFilterF self) -> size_t"""
        return _Math.ChainFilterF_filterCount(self)


    def apply(self, n, inout):
        """apply(ChainFilterF self, int n, float * inout)"""
        return _Math.ChainFilterF_apply(self, n, inout)


    def setStartTime(self, time):
        """setStartTime(ChainFilterF self, Time time)"""
        return _Math.ChainFilterF_setStartTime(self, time)


    def setStreamID(self, net, sta, loc, cha):
        """setStreamID(ChainFilterF self, std::string const & net, std::string const & sta, std::string const & loc, std::string const & cha)"""
        return _Math.ChainFilterF_setStreamID(self, net, sta, loc, cha)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ChainFilterF self, double fsamp)"""
        return _Math.ChainFilterF_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ChainFilterF self, int n, double const * params) -> int"""
        return _Math.ChainFilterF_setParameters(self, n, params)


    def clone(self):
        """clone(ChainFilterF self) -> InPlaceFilterF"""
        return _Math.ChainFilterF_clone(self)

ChainFilterF_swigregister = _Math.ChainFilterF_swigregister
ChainFilterF_swigregister(ChainFilterF)

class ChainFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::ChainFilter<(double)> class."""

    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChainFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChainFilterD, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Seiscomp::Math::Filtering::ChainFilter<(double)> self) -> ChainFilterD"""
        this = _Math.new_ChainFilterD()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_ChainFilterD
    __del__ = lambda self: None

    def add(self, filter):
        """add(ChainFilterD self, InPlaceFilterD filter) -> bool"""
        return _Math.ChainFilterD_add(self, filter)


    def remove(self, pos):
        """remove(ChainFilterD self, size_t pos) -> bool"""
        return _Math.ChainFilterD_remove(self, pos)


    def take(self, pos):
        """take(ChainFilterD self, size_t pos) -> InPlaceFilterD"""
        return _Math.ChainFilterD_take(self, pos)


    def indexOf(self, filter):
        """indexOf(ChainFilterD self, InPlaceFilterD filter) -> size_t"""
        return _Math.ChainFilterD_indexOf(self, filter)


    def filterCount(self):
        """filterCount(ChainFilterD self) -> size_t"""
        return _Math.ChainFilterD_filterCount(self)


    def apply(self, n, inout):
        """apply(ChainFilterD self, int n, double * inout)"""
        return _Math.ChainFilterD_apply(self, n, inout)


    def setStartTime(self, time):
        """setStartTime(ChainFilterD self, Time time)"""
        return _Math.ChainFilterD_setStartTime(self, time)


    def setStreamID(self, net, sta, loc, cha):
        """setStreamID(ChainFilterD self, std::string const & net, std::string const & sta, std::string const & loc, std::string const & cha)"""
        return _Math.ChainFilterD_setStreamID(self, net, sta, loc, cha)


    def setSamplingFrequency(self, fsamp):
        """setSamplingFrequency(ChainFilterD self, double fsamp)"""
        return _Math.ChainFilterD_setSamplingFrequency(self, fsamp)


    def setParameters(self, n, params):
        """setParameters(ChainFilterD self, int n, double const * params) -> int"""
        return _Math.ChainFilterD_setParameters(self, n, params)


    def clone(self):
        """clone(ChainFilterD self) -> InPlaceFilterD"""
        return _Math.ChainFilterD_clone(self)

ChainFilterD_swigregister = _Math.ChainFilterD_swigregister
ChainFilterD_swigregister(ChainFilterD)

Displacement = _Math.Displacement
Velocity = _Math.Velocity
Acceleration = _Math.Acceleration
class FAP(_object):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::FAP class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FAP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FAP, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::SeismometerResponse::FAP self) -> FAP
        __init__(Seiscomp::Math::SeismometerResponse::FAP self, double f, double a, double p) -> FAP
        """
        this = _Math.new_FAP(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __lt__(self, other):
        """__lt__(FAP self, FAP other) -> bool"""
        return _Math.FAP___lt__(self, other)

    __swig_setmethods__["frequency"] = _Math.FAP_frequency_set
    __swig_getmethods__["frequency"] = _Math.FAP_frequency_get
    if _newclass:
        frequency = _swig_property(_Math.FAP_frequency_get, _Math.FAP_frequency_set)
    __swig_setmethods__["amplitude"] = _Math.FAP_amplitude_set
    __swig_getmethods__["amplitude"] = _Math.FAP_amplitude_get
    if _newclass:
        amplitude = _swig_property(_Math.FAP_amplitude_get, _Math.FAP_amplitude_set)
    __swig_setmethods__["phaseAngle"] = _Math.FAP_phaseAngle_set
    __swig_getmethods__["phaseAngle"] = _Math.FAP_phaseAngle_get
    if _newclass:
        phaseAngle = _swig_property(_Math.FAP_phaseAngle_get, _Math.FAP_phaseAngle_set)
    __swig_destroy__ = _Math.delete_FAP
    __del__ = lambda self: None
FAP_swigregister = _Math.FAP_swigregister
FAP_swigregister(FAP)

class PolesAndZeros(_object):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::PolesAndZeros class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolesAndZeros, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolesAndZeros, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::SeismometerResponse::PolesAndZeros self) -> PolesAndZeros
        __init__(Seiscomp::Math::SeismometerResponse::PolesAndZeros self, vectorc poles, vectorc zeros, double norm) -> PolesAndZeros
        __init__(Seiscomp::Math::SeismometerResponse::PolesAndZeros self, PolesAndZeros other) -> PolesAndZeros
        """
        this = _Math.new_PolesAndZeros(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["poles"] = _Math.PolesAndZeros_poles_set
    __swig_getmethods__["poles"] = _Math.PolesAndZeros_poles_get
    if _newclass:
        poles = _swig_property(_Math.PolesAndZeros_poles_get, _Math.PolesAndZeros_poles_set)
    __swig_setmethods__["zeros"] = _Math.PolesAndZeros_zeros_set
    __swig_getmethods__["zeros"] = _Math.PolesAndZeros_zeros_get
    if _newclass:
        zeros = _swig_property(_Math.PolesAndZeros_zeros_get, _Math.PolesAndZeros_zeros_set)
    __swig_setmethods__["norm"] = _Math.PolesAndZeros_norm_set
    __swig_getmethods__["norm"] = _Math.PolesAndZeros_norm_get
    if _newclass:
        norm = _swig_property(_Math.PolesAndZeros_norm_get, _Math.PolesAndZeros_norm_set)
    __swig_destroy__ = _Math.delete_PolesAndZeros
    __del__ = lambda self: None
PolesAndZeros_swigregister = _Math.PolesAndZeros_swigregister
PolesAndZeros_swigregister(PolesAndZeros)

class WoodAnderson(PolesAndZeros):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::WoodAnderson class."""

    __swig_setmethods__ = {}
    for _s in [PolesAndZeros]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WoodAnderson, name, value)
    __swig_getmethods__ = {}
    for _s in [PolesAndZeros]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WoodAnderson, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::SeismometerResponse::WoodAnderson self, Seiscomp::Math::GroundMotion input, Seiscomp::Math::SeismometerResponse::WoodAnderson::Config config) -> WoodAnderson
        __init__(Seiscomp::Math::SeismometerResponse::WoodAnderson self, Seiscomp::Math::GroundMotion input) -> WoodAnderson
        """
        this = _Math.new_WoodAnderson(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_WoodAnderson
    __del__ = lambda self: None
WoodAnderson_swigregister = _Math.WoodAnderson_swigregister
WoodAnderson_swigregister(WoodAnderson)

class Seismometer5sec(PolesAndZeros):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::Seismometer5sec class."""

    __swig_setmethods__ = {}
    for _s in [PolesAndZeros]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Seismometer5sec, name, value)
    __swig_getmethods__ = {}
    for _s in [PolesAndZeros]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Seismometer5sec, name)
    __repr__ = _swig_repr

    def __init__(self, input):
        """__init__(Seiscomp::Math::SeismometerResponse::Seismometer5sec self, Seiscomp::Math::GroundMotion input) -> Seismometer5sec"""
        this = _Math.new_Seismometer5sec(input)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Math.delete_Seismometer5sec
    __del__ = lambda self: None
Seismometer5sec_swigregister = _Math.Seismometer5sec_swigregister
Seismometer5sec_swigregister(Seismometer5sec)

class WWSSN_SPF(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(float)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WWSSN_SPF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WWSSN_SPF, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(float)> self, Seiscomp::Math::GroundMotion input) -> WWSSN_SPF
        __init__(Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(float)> self) -> WWSSN_SPF
        __init__(Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(float)> self, WWSSN_SPF other) -> WWSSN_SPF
        """
        this = _Math.new_WWSSN_SPF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setParameters(self, n, params):
        """setParameters(WWSSN_SPF self, int n, double const * params) -> int"""
        return _Math.WWSSN_SPF_setParameters(self, n, params)


    def clone(self):
        """clone(WWSSN_SPF self) -> InPlaceFilterF"""
        return _Math.WWSSN_SPF_clone(self)


    def setInput(self, input):
        """setInput(WWSSN_SPF self, Seiscomp::Math::GroundMotion input)"""
        return _Math.WWSSN_SPF_setInput(self, input)

    __swig_destroy__ = _Math.delete_WWSSN_SPF
    __del__ = lambda self: None
WWSSN_SPF_swigregister = _Math.WWSSN_SPF_swigregister
WWSSN_SPF_swigregister(WWSSN_SPF)

class WWSSN_SPD(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(double)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WWSSN_SPD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WWSSN_SPD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(double)> self, Seiscomp::Math::GroundMotion input) -> WWSSN_SPD
        __init__(Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(double)> self) -> WWSSN_SPD
        __init__(Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(double)> self, WWSSN_SPD other) -> WWSSN_SPD
        """
        this = _Math.new_WWSSN_SPD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setParameters(self, n, params):
        """setParameters(WWSSN_SPD self, int n, double const * params) -> int"""
        return _Math.WWSSN_SPD_setParameters(self, n, params)


    def clone(self):
        """clone(WWSSN_SPD self) -> InPlaceFilterD"""
        return _Math.WWSSN_SPD_clone(self)


    def setInput(self, input):
        """setInput(WWSSN_SPD self, Seiscomp::Math::GroundMotion input)"""
        return _Math.WWSSN_SPD_setInput(self, input)

    __swig_destroy__ = _Math.delete_WWSSN_SPD
    __del__ = lambda self: None
WWSSN_SPD_swigregister = _Math.WWSSN_SPD_swigregister
WWSSN_SPD_swigregister(WWSSN_SPD)


def delazi(lat1, lon1, lat2, lon2):
    """delazi(double lat1, double lon1, double lat2, double lon2)"""
    return _Math.delazi(lat1, lon1, lat2, lon2)

def delazi_wgs84(lat1, lon1, lat2, lon2):
    """delazi_wgs84(double lat1, double lon1, double lat2, double lon2)"""
    return _Math.delazi_wgs84(lat1, lon1, lat2, lon2)

def delandaz2coord(dist, azi, lat0, lon0):
    """delandaz2coord(double dist, double azi, double lat0, double lon0)"""
    return _Math.delandaz2coord(dist, azi, lat0, lon0)

def scxsc(lat1, lon1, r1, lat2, lon2, r2, latx1, lonx1, latx2, lonx2, epsilon=0):
    """
    scxsc(double lat1, double lon1, double r1, double lat2, double lon2, double r2, double * latx1, double * lonx1, double * latx2, double * lonx2, double epsilon=0) -> int
    scxsc(double lat1, double lon1, double r1, double lat2, double lon2, double r2, double * latx1, double * lonx1, double * latx2, double * lonx2) -> int
    """
    return _Math.scxsc(lat1, lon1, r1, lat2, lon2, r2, latx1, lonx1, latx2, lonx2, epsilon)

def scdraw(lat0, lon0, radius, n, lat, lon):
    """scdraw(double lat0, double lon0, double radius, int n, double * lat, double * lon) -> int"""
    return _Math.scdraw(lat0, lon0, radius, n, lat, lon)
KM_OF_DEGREE = _Math.KM_OF_DEGREE

def xyz2ltp(x, y, z, lat, lon, alt):
    """xyz2ltp(double const x, double const y, double const z, double * lat, double * lon, double * alt)"""
    return _Math.xyz2ltp(x, y, z, lat, lon, alt)

def ltp2xyz(lat, lon, alt, x, y, z):
    """ltp2xyz(double lat, double lon, double alt, double * x, double * y, double * z)"""
    return _Math.ltp2xyz(lat, lon, alt, x, y, z)

def nearestHotspot(lat, lon, maxDist, coords):
    """nearestHotspot(double lat, double lon, double maxDist, HotspotListD coords) -> NamedCoordD"""
    return _Math.nearestHotspot(lat, lon, maxDist, coords)

def nearestCity(*args):
    """
    nearestCity(double lat, double lon, double maxDist, double minPopulation, int nCities, CityD cityArray) -> CityD
    nearestCity(double lat, double lon, double maxDist, double minPopulation, CityListD cities) -> CityD
    """
    return _Math.nearestCity(*args)

def largestCity(lat, lon, maxDist, cities):
    """largestCity(double lat, double lon, double maxDist, CityListD cities) -> CityD"""
    return _Math.largestCity(lat, lon, maxDist, cities)
class PositionInterpolator(_object):
    """Proxy of C++ Seiscomp::Math::Geo::PositionInterpolator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PositionInterpolator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PositionInterpolator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Geo::PositionInterpolator self, double lat1, double lon1, double lat2, double lon2, int steps) -> PositionInterpolator
        __init__(Seiscomp::Math::Geo::PositionInterpolator self, double lat1, double lon1, double lat2, double lon2, double stepsDistScale) -> PositionInterpolator
        """
        this = _Math.new_PositionInterpolator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def end(self):
        """end(PositionInterpolator self) -> bool"""
        return _Math.PositionInterpolator_end(self)


    def overallDistance(self):
        """overallDistance(PositionInterpolator self) -> double"""
        return _Math.PositionInterpolator_overallDistance(self)


    def distance(self):
        """distance(PositionInterpolator self) -> double"""
        return _Math.PositionInterpolator_distance(self)


    def azimuth(self):
        """azimuth(PositionInterpolator self) -> double"""
        return _Math.PositionInterpolator_azimuth(self)


    def latitude(self):
        """latitude(PositionInterpolator self) -> double"""
        return _Math.PositionInterpolator_latitude(self)


    def longitude(self):
        """longitude(PositionInterpolator self) -> double"""
        return _Math.PositionInterpolator_longitude(self)

    __swig_destroy__ = _Math.delete_PositionInterpolator
    __del__ = lambda self: None
PositionInterpolator_swigregister = _Math.PositionInterpolator_swigregister
PositionInterpolator_swigregister(PositionInterpolator)


def deg2km(deg):
    """deg2km(double deg) -> double"""
    return _Math.deg2km(deg)
class TransferFunction(seiscomp3.Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Restitution::FFT::TransferFunction class."""

    __swig_setmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransferFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [seiscomp3.Core.BaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransferFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __mul__(self, a):
        """__mul__(TransferFunction self, TransferFunction a) -> TransferFunction"""
        return _Math.TransferFunction___mul__(self, a)


    def __truediv__(self, *args):
        return _Math.TransferFunction___truediv__(self, *args)
    __div__ = __truediv__



    def evaluate(self, *args):
        """
        evaluate(TransferFunction self, Seiscomp::Math::Complex * out, int n, double const * x)
        evaluate(TransferFunction self, vectorc out, vectord x)
        """
        return _Math.TransferFunction_evaluate(self, *args)


    def deconvolve(self, *args):
        """
        deconvolve(TransferFunction self, int n, Seiscomp::Math::Complex * spec, double startFreq, double df)
        deconvolve(TransferFunction self, vectorc spec, double startFreq, double df)
        """
        return _Math.TransferFunction_deconvolve(self, *args)


    def convolve(self, *args):
        """
        convolve(TransferFunction self, int n, Seiscomp::Math::Complex * spec, double startFreq, double df)
        convolve(TransferFunction self, vectorc spec, double startFreq, double df)
        """
        return _Math.TransferFunction_convolve(self, *args)

    __swig_destroy__ = _Math.delete_TransferFunction
    __del__ = lambda self: None
TransferFunction_swigregister = _Math.TransferFunction_swigregister
TransferFunction_swigregister(TransferFunction)

class TransferFunctionPAZ(TransferFunction):
    """Proxy of C++ Seiscomp::Math::Restitution::FFT::PolesAndZeros class."""

    __swig_setmethods__ = {}
    for _s in [TransferFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransferFunctionPAZ, name, value)
    __swig_getmethods__ = {}
    for _s in [TransferFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransferFunctionPAZ, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        PolesAndZeros(PolesAndZeros polesAndZeros) -> TransferFunctionPAZ
        PolesAndZeros(int n_poles, Seiscomp::Math::Restitution::Pole * poles, int n_zeros, Seiscomp::Math::Restitution::Zero * zeros, double k, int addZeros=0) -> TransferFunctionPAZ
        __init__(Seiscomp::Math::Restitution::FFT::PolesAndZeros self, int n_poles, Seiscomp::Math::Restitution::Pole * poles, int n_zeros, Seiscomp::Math::Restitution::Zero * zeros, double k) -> TransferFunctionPAZ
        """
        this = _Math.new_TransferFunctionPAZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["paz"] = _Math.TransferFunctionPAZ_paz_set
    __swig_getmethods__["paz"] = _Math.TransferFunctionPAZ_paz_get
    if _newclass:
        paz = _swig_property(_Math.TransferFunctionPAZ_paz_get, _Math.TransferFunctionPAZ_paz_set)
    __swig_destroy__ = _Math.delete_TransferFunctionPAZ
    __del__ = lambda self: None
TransferFunctionPAZ_swigregister = _Math.TransferFunctionPAZ_swigregister
TransferFunctionPAZ_swigregister(TransferFunctionPAZ)

class ResponseList(TransferFunction):
    """Proxy of C++ Seiscomp::Math::Restitution::FFT::ResponseList class."""

    __swig_setmethods__ = {}
    for _s in [TransferFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResponseList, name, value)
    __swig_getmethods__ = {}
    for _s in [TransferFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ResponseList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Seiscomp::Math::Restitution::FFT::ResponseList self, Seiscomp::Math::SeismometerResponse::FAPs const & faps, int addZeros=0) -> ResponseList
        __init__(Seiscomp::Math::Restitution::FFT::ResponseList self, Seiscomp::Math::SeismometerResponse::FAPs const & faps) -> ResponseList
        __init__(Seiscomp::Math::Restitution::FFT::ResponseList self, int n_tuples, FAP faps, int addZeros=0) -> ResponseList
        __init__(Seiscomp::Math::Restitution::FFT::ResponseList self, int n_tuples, FAP faps) -> ResponseList
        """
        this = _Math.new_ResponseList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["faps"] = _Math.ResponseList_faps_set
    __swig_getmethods__["faps"] = _Math.ResponseList_faps_get
    if _newclass:
        faps = _swig_property(_Math.ResponseList_faps_get, _Math.ResponseList_faps_set)
    __swig_setmethods__["nZeros"] = _Math.ResponseList_nZeros_set
    __swig_getmethods__["nZeros"] = _Math.ResponseList_nZeros_get
    if _newclass:
        nZeros = _swig_property(_Math.ResponseList_nZeros_get, _Math.ResponseList_nZeros_set)
    __swig_destroy__ = _Math.delete_ResponseList
    __del__ = lambda self: None
ResponseList_swigregister = _Math.ResponseList_swigregister
ResponseList_swigregister(ResponseList)

class vectorc(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Complex)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorc, name)
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vectorc self) -> SwigPyIterator"""
        return _Math.vectorc_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vectorc self) -> bool"""
        return _Math.vectorc___nonzero__(self)


    def __bool__(self):
        """__bool__(vectorc self) -> bool"""
        return _Math.vectorc___bool__(self)


    def __len__(self):
        """__len__(vectorc self) -> std::vector< std::complex< double > >::size_type"""
        return _Math.vectorc___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vectorc self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> vectorc"""
        return _Math.vectorc___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vectorc self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)
        __setslice__(vectorc self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, vectorc v)
        """
        return _Math.vectorc___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vectorc self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _Math.vectorc___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vectorc self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(vectorc self, PySliceObject * slice)
        """
        return _Math.vectorc___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vectorc self, PySliceObject * slice) -> vectorc
        __getitem__(vectorc self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _Math.vectorc___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vectorc self, PySliceObject * slice, vectorc v)
        __setitem__(vectorc self, PySliceObject * slice)
        __setitem__(vectorc self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _Math.vectorc___setitem__(self, *args)


    def pop(self):
        """pop(vectorc self) -> std::vector< std::complex< double > >::value_type"""
        return _Math.vectorc_pop(self)


    def append(self, x):
        """append(vectorc self, std::vector< std::complex< double > >::value_type const & x)"""
        return _Math.vectorc_append(self, x)


    def empty(self):
        """empty(vectorc self) -> bool"""
        return _Math.vectorc_empty(self)


    def size(self):
        """size(vectorc self) -> std::vector< std::complex< double > >::size_type"""
        return _Math.vectorc_size(self)


    def swap(self, v):
        """swap(vectorc self, vectorc v)"""
        return _Math.vectorc_swap(self, v)


    def begin(self):
        """begin(vectorc self) -> std::vector< std::complex< double > >::iterator"""
        return _Math.vectorc_begin(self)


    def end(self):
        """end(vectorc self) -> std::vector< std::complex< double > >::iterator"""
        return _Math.vectorc_end(self)


    def rbegin(self):
        """rbegin(vectorc self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _Math.vectorc_rbegin(self)


    def rend(self):
        """rend(vectorc self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _Math.vectorc_rend(self)


    def clear(self):
        """clear(vectorc self)"""
        return _Math.vectorc_clear(self)


    def get_allocator(self):
        """get_allocator(vectorc self) -> std::vector< std::complex< double > >::allocator_type"""
        return _Math.vectorc_get_allocator(self)


    def pop_back(self):
        """pop_back(vectorc self)"""
        return _Math.vectorc_pop_back(self)


    def erase(self, *args):
        """
        erase(vectorc self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(vectorc self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _Math.vectorc_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(Seiscomp::Math::Complex)> self) -> vectorc
        __init__(std::vector<(Seiscomp::Math::Complex)> self, vectorc arg2) -> vectorc
        __init__(std::vector<(Seiscomp::Math::Complex)> self, std::vector< std::complex< double > >::size_type size) -> vectorc
        __init__(std::vector<(Seiscomp::Math::Complex)> self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> vectorc
        """
        this = _Math.new_vectorc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vectorc self, std::vector< std::complex< double > >::value_type const & x)"""
        return _Math.vectorc_push_back(self, x)


    def front(self):
        """front(vectorc self) -> std::vector< std::complex< double > >::value_type const &"""
        return _Math.vectorc_front(self)


    def back(self):
        """back(vectorc self) -> std::vector< std::complex< double > >::value_type const &"""
        return _Math.vectorc_back(self)


    def assign(self, n, x):
        """assign(vectorc self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _Math.vectorc_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vectorc self, std::vector< std::complex< double > >::size_type new_size)
        resize(vectorc self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _Math.vectorc_resize(self, *args)


    def insert(self, *args):
        """
        insert(vectorc self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(vectorc self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)
        """
        return _Math.vectorc_insert(self, *args)


    def reserve(self, n):
        """reserve(vectorc self, std::vector< std::complex< double > >::size_type n)"""
        return _Math.vectorc_reserve(self, n)


    def capacity(self):
        """capacity(vectorc self) -> std::vector< std::complex< double > >::size_type"""
        return _Math.vectorc_capacity(self)

    __swig_destroy__ = _Math.delete_vectorc
    __del__ = lambda self: None
vectorc_swigregister = _Math.vectorc_swigregister
vectorc_swigregister(vectorc)

# This file is compatible with both classic and new-style classes.


